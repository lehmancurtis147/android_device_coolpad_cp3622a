#line 1 "external/sepolicy/security_classes"
# FLASK

#
# Define the security object classes
#

# Classes marked as userspace are classes
# for userspace object managers

class security
class process
class system
class capability

# file-related classes
class filesystem
class file
class dir
class fd
class lnk_file
class chr_file
class blk_file
class sock_file
class fifo_file

# network-related classes
class socket
class tcp_socket
class udp_socket
class rawip_socket
class node
class netif
class netlink_socket
class packet_socket
class key_socket
class unix_stream_socket
class unix_dgram_socket

# sysv-ipc-related classes
class sem
class msg
class msgq
class shm
class ipc

#
# userspace object manager classes
#

# passwd/chfn/chsh
class passwd			# userspace

# SE-X Windows stuff (more classes below)
class x_drawable		# userspace
class x_screen			# userspace
class x_gc			# userspace
class x_font			# userspace
class x_colormap		# userspace
class x_property		# userspace
class x_selection		# userspace
class x_cursor			# userspace
class x_client			# userspace
class x_device			# userspace
class x_server			# userspace
class x_extension		# userspace

# extended netlink sockets
class netlink_route_socket
class netlink_firewall_socket
class netlink_tcpdiag_socket
class netlink_nflog_socket
class netlink_xfrm_socket
class netlink_selinux_socket
class netlink_audit_socket
class netlink_ip6fw_socket
class netlink_dnrt_socket

class dbus			# userspace
class nscd			# userspace

# IPSec association
class association

# Updated Netlink class for KOBJECT_UEVENT family.
class netlink_kobject_uevent_socket

class appletalk_socket

class packet

# Kernel access key retention
class key

class context			# userspace

class dccp_socket

class memprotect

class db_database		# userspace
class db_table			# userspace
class db_procedure		# userspace
class db_column			# userspace
class db_tuple			# userspace
class db_blob			# userspace

# network peer labels
class peer

# Capabilities >= 32
class capability2

# More SE-X Windows stuff
class x_resource		# userspace
class x_event			# userspace
class x_synthetic_event		# userspace
class x_application_data	# userspace

# kernel services that need to override task security, e.g. cachefiles
class kernel_service

class tun_socket

# Still More SE-X Windows stuff
class x_pointer			# userspace
class x_keyboard		# userspace

# More Database stuff
class db_schema			# userspace
class db_view			# userspace
class db_sequence		# userspace
class db_language		# userspace

class binder
class zygote

# Property service
class property_service          # userspace

# Service manager
class service_manager           # userspace

# Keystore Key
class keystore_key              # userspace

# FLASK
#line 1 "external/sepolicy/initial_sids"
# FLASK

#
# Define initial security identifiers
#

sid kernel
sid security
sid unlabeled
sid fs
sid file
sid file_labels
sid init
sid any_socket
sid port
sid netif
sid netmsg
sid node
sid igmp_packet
sid icmp_socket
sid tcp_socket
sid sysctl_modprobe
sid sysctl
sid sysctl_fs
sid sysctl_kernel
sid sysctl_net
sid sysctl_net_unix
sid sysctl_vm
sid sysctl_dev
sid kmod
sid policy
sid scmp_packet
sid devnull

# FLASK
#line 1 "external/sepolicy/access_vectors"
#
# Define common prefixes for access vectors
#
# common common_name { permission_name ... }


#
# Define a common prefix for file access vectors.
#

common file
{
	ioctl
	read
	write
	create
	getattr
	setattr
	lock
	relabelfrom
	relabelto
	append
	unlink
	link
	rename
	execute
	swapon
	quotaon
	mounton
}


#
# Define a common prefix for socket access vectors.
#

common socket
{
# inherited from file
	ioctl
	read
	write
	create
	getattr
	setattr
	lock
	relabelfrom
	relabelto
	append
# socket-specific
	bind
	connect
	listen
	accept
	getopt
	setopt
	shutdown
	recvfrom
	sendto
	recv_msg
	send_msg
	name_bind
}

#
# Define a common prefix for ipc access vectors.
#

common ipc
{
	create
	destroy
	getattr
	setattr
	read
	write
	associate
	unix_read
	unix_write
}

#
#  Define a common prefix for userspace database object access vectors.
#

common database
{
	create
	drop
	getattr
	setattr
	relabelfrom
	relabelto
}

#
# Define a common prefix for pointer and keyboard access vectors.
#

common x_device
{
	getattr
	setattr
	use
	read
	write
	getfocus
	setfocus
	bell
	force_cursor
	freeze
	grab
	manage
	list_property
	get_property
	set_property
	add
	remove
	create
	destroy
}

#
# Define the access vectors.
#
# class class_name [ inherits common_name ] { permission_name ... }


#
# Define the access vector interpretation for file-related objects.
#

class filesystem
{
	mount
	remount
	unmount
	getattr
	relabelfrom
	relabelto
	transition
	associate
	quotamod
	quotaget
}

class dir
inherits file
{
	add_name
	remove_name
	reparent
	search
	rmdir
	open
	audit_access
	execmod
}

class file
inherits file
{
	execute_no_trans
	entrypoint
	execmod
	open
	audit_access
}

class lnk_file
inherits file
{
	open
	audit_access
	execmod
}

class chr_file
inherits file
{
	execute_no_trans
	entrypoint
	execmod
	open
	audit_access
}

class blk_file
inherits file
{
	open
	audit_access
	execmod
}

class sock_file
inherits file
{
	open
	audit_access
	execmod
}

class fifo_file
inherits file
{
	open
	audit_access
	execmod
}

class fd
{
	use
}


#
# Define the access vector interpretation for network-related objects.
#

class socket
inherits socket

class tcp_socket
inherits socket
{
	connectto
	newconn
	acceptfrom
	node_bind
	name_connect
}

class udp_socket
inherits socket
{
	node_bind
}

class rawip_socket
inherits socket
{
	node_bind
}

class node
{
	tcp_recv
	tcp_send
	udp_recv
	udp_send
	rawip_recv
	rawip_send
	enforce_dest
	dccp_recv
	dccp_send
	recvfrom
	sendto
}

class netif
{
	tcp_recv
	tcp_send
	udp_recv
	udp_send
	rawip_recv
	rawip_send
	dccp_recv
	dccp_send
	ingress
	egress
}

class netlink_socket
inherits socket

class packet_socket
inherits socket

class key_socket
inherits socket

class unix_stream_socket
inherits socket
{
	connectto
	newconn
	acceptfrom
}

class unix_dgram_socket
inherits socket

#
# Define the access vector interpretation for process-related objects
#

class process
{
	fork
	transition
	sigchld # commonly granted from child to parent
	sigkill # cannot be caught or ignored
	sigstop # cannot be caught or ignored
	signull # for kill(pid, 0)
	signal  # all other signals
	ptrace
	getsched
	setsched
	getsession
	getpgid
	setpgid
	getcap
	setcap
	share
	getattr
	setexec
	setfscreate
	noatsecure
	siginh
	setrlimit
	rlimitinh
	dyntransition
	setcurrent
	execmem
	execstack
	execheap
	setkeycreate
	setsockcreate
}


#
# Define the access vector interpretation for ipc-related objects
#

class ipc
inherits ipc

class sem
inherits ipc

class msgq
inherits ipc
{
	enqueue
}

class msg
{
	send
	receive
}

class shm
inherits ipc
{
	lock
}


#
# Define the access vector interpretation for the security server.
#

class security
{
	compute_av
	compute_create
	compute_member
	check_context
	load_policy
	compute_relabel
	compute_user
	setenforce     # was avc_toggle in system class
	setbool
	setsecparam
	setcheckreqprot
	read_policy
}


#
# Define the access vector interpretation for system operations.
#

class system
{
	ipc_info
	syslog_read
	syslog_mod
	syslog_console
	module_request
}

#
# Define the access vector interpretation for controling capabilies
#

class capability
{
	# The capabilities are defined in include/linux/capability.h
	# Capabilities >= 32 are defined in the capability2 class.
	# Care should be taken to ensure that these are consistent with
	# those definitions. (Order matters)

	chown
	dac_override
	dac_read_search
	fowner
	fsetid
	kill
	setgid
	setuid
	setpcap
	linux_immutable
	net_bind_service
	net_broadcast
	net_admin
	net_raw
	ipc_lock
	ipc_owner
	sys_module
	sys_rawio
	sys_chroot
	sys_ptrace
	sys_pacct
	sys_admin
	sys_boot
	sys_nice
	sys_resource
	sys_time
	sys_tty_config
	mknod
	lease
	audit_write
	audit_control
	setfcap
}

class capability2
{
	mac_override	# unused by SELinux
	mac_admin	# unused by SELinux
	syslog
	wake_alarm
	block_suspend
}

#
# Define the access vector interpretation for controlling
# changes to passwd information.
#
class passwd
{
	passwd	# change another user passwd
	chfn	# change another user finger info
	chsh	# change another user shell
	rootok  # pam_rootok check (skip auth)
	crontab # crontab on another user
}

#
# SE-X Windows stuff
#
class x_drawable
{
	create
	destroy
	read
	write
	blend
	getattr
	setattr
	list_child
	add_child
	remove_child
	list_property
	get_property
	set_property
	manage
	override
	show
	hide
	send
	receive
}

class x_screen
{
	getattr
	setattr
	hide_cursor
	show_cursor
	saver_getattr
	saver_setattr
	saver_hide
	saver_show
}

class x_gc
{
	create
	destroy
	getattr
	setattr
	use
}

class x_font
{
	create
	destroy
	getattr
	add_glyph
	remove_glyph
	use
}

class x_colormap
{
	create
	destroy
	read
	write
	getattr
	add_color
	remove_color
	install
	uninstall
	use
}

class x_property
{
	create
	destroy
	read
	write
	append
	getattr
	setattr
}

class x_selection
{
	read
	write
	getattr
	setattr
}

class x_cursor
{
	create
	destroy
	read
	write
	getattr
	setattr
	use
}

class x_client
{
	destroy
	getattr
	setattr
	manage
}

class x_device
inherits x_device

class x_server
{
	getattr
	setattr
	record
	debug
	grab
	manage
}

class x_extension
{
	query
	use
}

class x_resource
{
	read
	write
}

class x_event
{
	send
	receive
}

class x_synthetic_event
{
	send
	receive
}

#
# Extended Netlink classes
#
class netlink_route_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_firewall_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_tcpdiag_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_nflog_socket
inherits socket

class netlink_xfrm_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_selinux_socket
inherits socket

class netlink_audit_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
	nlmsg_relay
	nlmsg_readpriv
	nlmsg_tty_audit
}

class netlink_ip6fw_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_dnrt_socket
inherits socket

# Define the access vector interpretation for controlling
# access and communication through the D-BUS messaging
# system.
#
class dbus
{
	acquire_svc
	send_msg
}

# Define the access vector interpretation for controlling
# access through the name service cache daemon (nscd).
#
class nscd
{
	getpwd
	getgrp
	gethost
	getstat
	admin
	shmempwd
	shmemgrp
	shmemhost
	getserv
	shmemserv
}

# Define the access vector interpretation for controlling
# access to IPSec network data by association
#
class association
{
	sendto
	recvfrom
	setcontext
	polmatch
}

# Updated Netlink class for KOBJECT_UEVENT family.
class netlink_kobject_uevent_socket
inherits socket

class appletalk_socket
inherits socket

class packet
{
	send
	recv
	relabelto
	flow_in		# deprecated
	flow_out	# deprecated
	forward_in
	forward_out
}

class key
{
	view
	read
	write
	search
	link
	setattr
	create
}

class context
{
	translate
	contains
}

class dccp_socket
inherits socket
{
	node_bind
	name_connect
}

class memprotect
{
	mmap_zero
}

class db_database
inherits database
{
	access
	install_module
	load_module
	get_param	# deprecated
	set_param	# deprecated
}

class db_table
inherits database
{
	use		# deprecated
	select
	update
	insert
	delete
	lock
}

class db_procedure
inherits database
{
	execute
	entrypoint
	install
}

class db_column
inherits database
{
	use		# deprecated
	select
	update
	insert
}

class db_tuple
{
	relabelfrom
	relabelto
	use		# deprecated
	select
	update
	insert
	delete
}

class db_blob
inherits database
{
	read
	write
	import
	export
}

# network peer labels
class peer
{
	recv
}

class x_application_data
{
	paste
	paste_after_confirm
	copy
}

class kernel_service
{
	use_as_override
	create_files_as
}

class tun_socket
inherits socket
{
	attach_queue
}

class x_pointer
inherits x_device

class x_keyboard
inherits x_device

class db_schema
inherits database
{
	search
	add_name
	remove_name
}

class db_view
inherits database
{
	expand
}

class db_sequence
inherits database
{
	get_value
	next_value
	set_value
}

class db_language
inherits database
{
	implement
	execute
}

class binder
{
	impersonate
	call
	set_context_mgr
	transfer
}

class zygote
{
	specifyids
	specifyrlimits
	specifyinvokewith
	specifyseinfo
}

class property_service
{
	set
}

class service_manager
{
	add
	find
	list
}

class keystore_key
{
	test
	get
	insert
	delete
	exist
	saw
	reset
	password
	lock
	unlock
	zero
	sign
	verify
	grant
	duplicate
	clear_uid
	reset_uid
	sync_uid
	password_uid
}
#line 1 "external/sepolicy/global_macros"
#####################################
# Common groupings of object classes.
#














#####################################
# Common groupings of permissions.
#





















#####################################
# Common socket permission sets.




#line 1 "external/sepolicy/mls_macros"
########################################
#
# gen_cats(N)
#
# declares categores c0 to c(N-1)
#
#line 10




########################################
#
# gen_sens(N)
#
# declares sensitivites s0 to s(N-1) with dominance
# in increasing numeric order with s0 lowest, s(N-1) highest
#
#line 24




#line 34


########################################
#
# gen_levels(N,M)
#
# levels from s0 to (N-1) with categories c0 to (M-1)
#
#line 45




########################################
#
# Basic level names for system low and high
#


#line 1 "external/sepolicy/mls"
#########################################
# MLS declarations
#

# Generate the desired number of sensitivities and categories.

#line 6
# Each sensitivity has a name and zero or more aliases.
#line 6
sensitivity s0;
#line 6

#line 6

#line 6
# Define the ordering of the sensitivity levels (least to greatest)
#line 6
dominance { s0  }
#line 6

category c0;
#line 7
category c1;
#line 7
category c2;
#line 7
category c3;
#line 7
category c4;
#line 7
category c5;
#line 7
category c6;
#line 7
category c7;
#line 7
category c8;
#line 7
category c9;
#line 7
category c10;
#line 7
category c11;
#line 7
category c12;
#line 7
category c13;
#line 7
category c14;
#line 7
category c15;
#line 7
category c16;
#line 7
category c17;
#line 7
category c18;
#line 7
category c19;
#line 7
category c20;
#line 7
category c21;
#line 7
category c22;
#line 7
category c23;
#line 7
category c24;
#line 7
category c25;
#line 7
category c26;
#line 7
category c27;
#line 7
category c28;
#line 7
category c29;
#line 7
category c30;
#line 7
category c31;
#line 7
category c32;
#line 7
category c33;
#line 7
category c34;
#line 7
category c35;
#line 7
category c36;
#line 7
category c37;
#line 7
category c38;
#line 7
category c39;
#line 7
category c40;
#line 7
category c41;
#line 7
category c42;
#line 7
category c43;
#line 7
category c44;
#line 7
category c45;
#line 7
category c46;
#line 7
category c47;
#line 7
category c48;
#line 7
category c49;
#line 7
category c50;
#line 7
category c51;
#line 7
category c52;
#line 7
category c53;
#line 7
category c54;
#line 7
category c55;
#line 7
category c56;
#line 7
category c57;
#line 7
category c58;
#line 7
category c59;
#line 7
category c60;
#line 7
category c61;
#line 7
category c62;
#line 7
category c63;
#line 7
category c64;
#line 7
category c65;
#line 7
category c66;
#line 7
category c67;
#line 7
category c68;
#line 7
category c69;
#line 7
category c70;
#line 7
category c71;
#line 7
category c72;
#line 7
category c73;
#line 7
category c74;
#line 7
category c75;
#line 7
category c76;
#line 7
category c77;
#line 7
category c78;
#line 7
category c79;
#line 7
category c80;
#line 7
category c81;
#line 7
category c82;
#line 7
category c83;
#line 7
category c84;
#line 7
category c85;
#line 7
category c86;
#line 7
category c87;
#line 7
category c88;
#line 7
category c89;
#line 7
category c90;
#line 7
category c91;
#line 7
category c92;
#line 7
category c93;
#line 7
category c94;
#line 7
category c95;
#line 7
category c96;
#line 7
category c97;
#line 7
category c98;
#line 7
category c99;
#line 7
category c100;
#line 7
category c101;
#line 7
category c102;
#line 7
category c103;
#line 7
category c104;
#line 7
category c105;
#line 7
category c106;
#line 7
category c107;
#line 7
category c108;
#line 7
category c109;
#line 7
category c110;
#line 7
category c111;
#line 7
category c112;
#line 7
category c113;
#line 7
category c114;
#line 7
category c115;
#line 7
category c116;
#line 7
category c117;
#line 7
category c118;
#line 7
category c119;
#line 7
category c120;
#line 7
category c121;
#line 7
category c122;
#line 7
category c123;
#line 7
category c124;
#line 7
category c125;
#line 7
category c126;
#line 7
category c127;
#line 7
category c128;
#line 7
category c129;
#line 7
category c130;
#line 7
category c131;
#line 7
category c132;
#line 7
category c133;
#line 7
category c134;
#line 7
category c135;
#line 7
category c136;
#line 7
category c137;
#line 7
category c138;
#line 7
category c139;
#line 7
category c140;
#line 7
category c141;
#line 7
category c142;
#line 7
category c143;
#line 7
category c144;
#line 7
category c145;
#line 7
category c146;
#line 7
category c147;
#line 7
category c148;
#line 7
category c149;
#line 7
category c150;
#line 7
category c151;
#line 7
category c152;
#line 7
category c153;
#line 7
category c154;
#line 7
category c155;
#line 7
category c156;
#line 7
category c157;
#line 7
category c158;
#line 7
category c159;
#line 7
category c160;
#line 7
category c161;
#line 7
category c162;
#line 7
category c163;
#line 7
category c164;
#line 7
category c165;
#line 7
category c166;
#line 7
category c167;
#line 7
category c168;
#line 7
category c169;
#line 7
category c170;
#line 7
category c171;
#line 7
category c172;
#line 7
category c173;
#line 7
category c174;
#line 7
category c175;
#line 7
category c176;
#line 7
category c177;
#line 7
category c178;
#line 7
category c179;
#line 7
category c180;
#line 7
category c181;
#line 7
category c182;
#line 7
category c183;
#line 7
category c184;
#line 7
category c185;
#line 7
category c186;
#line 7
category c187;
#line 7
category c188;
#line 7
category c189;
#line 7
category c190;
#line 7
category c191;
#line 7
category c192;
#line 7
category c193;
#line 7
category c194;
#line 7
category c195;
#line 7
category c196;
#line 7
category c197;
#line 7
category c198;
#line 7
category c199;
#line 7
category c200;
#line 7
category c201;
#line 7
category c202;
#line 7
category c203;
#line 7
category c204;
#line 7
category c205;
#line 7
category c206;
#line 7
category c207;
#line 7
category c208;
#line 7
category c209;
#line 7
category c210;
#line 7
category c211;
#line 7
category c212;
#line 7
category c213;
#line 7
category c214;
#line 7
category c215;
#line 7
category c216;
#line 7
category c217;
#line 7
category c218;
#line 7
category c219;
#line 7
category c220;
#line 7
category c221;
#line 7
category c222;
#line 7
category c223;
#line 7
category c224;
#line 7
category c225;
#line 7
category c226;
#line 7
category c227;
#line 7
category c228;
#line 7
category c229;
#line 7
category c230;
#line 7
category c231;
#line 7
category c232;
#line 7
category c233;
#line 7
category c234;
#line 7
category c235;
#line 7
category c236;
#line 7
category c237;
#line 7
category c238;
#line 7
category c239;
#line 7
category c240;
#line 7
category c241;
#line 7
category c242;
#line 7
category c243;
#line 7
category c244;
#line 7
category c245;
#line 7
category c246;
#line 7
category c247;
#line 7
category c248;
#line 7
category c249;
#line 7
category c250;
#line 7
category c251;
#line 7
category c252;
#line 7
category c253;
#line 7
category c254;
#line 7
category c255;
#line 7
category c256;
#line 7
category c257;
#line 7
category c258;
#line 7
category c259;
#line 7
category c260;
#line 7
category c261;
#line 7
category c262;
#line 7
category c263;
#line 7
category c264;
#line 7
category c265;
#line 7
category c266;
#line 7
category c267;
#line 7
category c268;
#line 7
category c269;
#line 7
category c270;
#line 7
category c271;
#line 7
category c272;
#line 7
category c273;
#line 7
category c274;
#line 7
category c275;
#line 7
category c276;
#line 7
category c277;
#line 7
category c278;
#line 7
category c279;
#line 7
category c280;
#line 7
category c281;
#line 7
category c282;
#line 7
category c283;
#line 7
category c284;
#line 7
category c285;
#line 7
category c286;
#line 7
category c287;
#line 7
category c288;
#line 7
category c289;
#line 7
category c290;
#line 7
category c291;
#line 7
category c292;
#line 7
category c293;
#line 7
category c294;
#line 7
category c295;
#line 7
category c296;
#line 7
category c297;
#line 7
category c298;
#line 7
category c299;
#line 7
category c300;
#line 7
category c301;
#line 7
category c302;
#line 7
category c303;
#line 7
category c304;
#line 7
category c305;
#line 7
category c306;
#line 7
category c307;
#line 7
category c308;
#line 7
category c309;
#line 7
category c310;
#line 7
category c311;
#line 7
category c312;
#line 7
category c313;
#line 7
category c314;
#line 7
category c315;
#line 7
category c316;
#line 7
category c317;
#line 7
category c318;
#line 7
category c319;
#line 7
category c320;
#line 7
category c321;
#line 7
category c322;
#line 7
category c323;
#line 7
category c324;
#line 7
category c325;
#line 7
category c326;
#line 7
category c327;
#line 7
category c328;
#line 7
category c329;
#line 7
category c330;
#line 7
category c331;
#line 7
category c332;
#line 7
category c333;
#line 7
category c334;
#line 7
category c335;
#line 7
category c336;
#line 7
category c337;
#line 7
category c338;
#line 7
category c339;
#line 7
category c340;
#line 7
category c341;
#line 7
category c342;
#line 7
category c343;
#line 7
category c344;
#line 7
category c345;
#line 7
category c346;
#line 7
category c347;
#line 7
category c348;
#line 7
category c349;
#line 7
category c350;
#line 7
category c351;
#line 7
category c352;
#line 7
category c353;
#line 7
category c354;
#line 7
category c355;
#line 7
category c356;
#line 7
category c357;
#line 7
category c358;
#line 7
category c359;
#line 7
category c360;
#line 7
category c361;
#line 7
category c362;
#line 7
category c363;
#line 7
category c364;
#line 7
category c365;
#line 7
category c366;
#line 7
category c367;
#line 7
category c368;
#line 7
category c369;
#line 7
category c370;
#line 7
category c371;
#line 7
category c372;
#line 7
category c373;
#line 7
category c374;
#line 7
category c375;
#line 7
category c376;
#line 7
category c377;
#line 7
category c378;
#line 7
category c379;
#line 7
category c380;
#line 7
category c381;
#line 7
category c382;
#line 7
category c383;
#line 7
category c384;
#line 7
category c385;
#line 7
category c386;
#line 7
category c387;
#line 7
category c388;
#line 7
category c389;
#line 7
category c390;
#line 7
category c391;
#line 7
category c392;
#line 7
category c393;
#line 7
category c394;
#line 7
category c395;
#line 7
category c396;
#line 7
category c397;
#line 7
category c398;
#line 7
category c399;
#line 7
category c400;
#line 7
category c401;
#line 7
category c402;
#line 7
category c403;
#line 7
category c404;
#line 7
category c405;
#line 7
category c406;
#line 7
category c407;
#line 7
category c408;
#line 7
category c409;
#line 7
category c410;
#line 7
category c411;
#line 7
category c412;
#line 7
category c413;
#line 7
category c414;
#line 7
category c415;
#line 7
category c416;
#line 7
category c417;
#line 7
category c418;
#line 7
category c419;
#line 7
category c420;
#line 7
category c421;
#line 7
category c422;
#line 7
category c423;
#line 7
category c424;
#line 7
category c425;
#line 7
category c426;
#line 7
category c427;
#line 7
category c428;
#line 7
category c429;
#line 7
category c430;
#line 7
category c431;
#line 7
category c432;
#line 7
category c433;
#line 7
category c434;
#line 7
category c435;
#line 7
category c436;
#line 7
category c437;
#line 7
category c438;
#line 7
category c439;
#line 7
category c440;
#line 7
category c441;
#line 7
category c442;
#line 7
category c443;
#line 7
category c444;
#line 7
category c445;
#line 7
category c446;
#line 7
category c447;
#line 7
category c448;
#line 7
category c449;
#line 7
category c450;
#line 7
category c451;
#line 7
category c452;
#line 7
category c453;
#line 7
category c454;
#line 7
category c455;
#line 7
category c456;
#line 7
category c457;
#line 7
category c458;
#line 7
category c459;
#line 7
category c460;
#line 7
category c461;
#line 7
category c462;
#line 7
category c463;
#line 7
category c464;
#line 7
category c465;
#line 7
category c466;
#line 7
category c467;
#line 7
category c468;
#line 7
category c469;
#line 7
category c470;
#line 7
category c471;
#line 7
category c472;
#line 7
category c473;
#line 7
category c474;
#line 7
category c475;
#line 7
category c476;
#line 7
category c477;
#line 7
category c478;
#line 7
category c479;
#line 7
category c480;
#line 7
category c481;
#line 7
category c482;
#line 7
category c483;
#line 7
category c484;
#line 7
category c485;
#line 7
category c486;
#line 7
category c487;
#line 7
category c488;
#line 7
category c489;
#line 7
category c490;
#line 7
category c491;
#line 7
category c492;
#line 7
category c493;
#line 7
category c494;
#line 7
category c495;
#line 7
category c496;
#line 7
category c497;
#line 7
category c498;
#line 7
category c499;
#line 7
category c500;
#line 7
category c501;
#line 7
category c502;
#line 7
category c503;
#line 7
category c504;
#line 7
category c505;
#line 7
category c506;
#line 7
category c507;
#line 7
category c508;
#line 7
category c509;
#line 7
category c510;
#line 7
category c511;
#line 7
category c512;
#line 7
category c513;
#line 7
category c514;
#line 7
category c515;
#line 7
category c516;
#line 7
category c517;
#line 7
category c518;
#line 7
category c519;
#line 7
category c520;
#line 7
category c521;
#line 7
category c522;
#line 7
category c523;
#line 7
category c524;
#line 7
category c525;
#line 7
category c526;
#line 7
category c527;
#line 7
category c528;
#line 7
category c529;
#line 7
category c530;
#line 7
category c531;
#line 7
category c532;
#line 7
category c533;
#line 7
category c534;
#line 7
category c535;
#line 7
category c536;
#line 7
category c537;
#line 7
category c538;
#line 7
category c539;
#line 7
category c540;
#line 7
category c541;
#line 7
category c542;
#line 7
category c543;
#line 7
category c544;
#line 7
category c545;
#line 7
category c546;
#line 7
category c547;
#line 7
category c548;
#line 7
category c549;
#line 7
category c550;
#line 7
category c551;
#line 7
category c552;
#line 7
category c553;
#line 7
category c554;
#line 7
category c555;
#line 7
category c556;
#line 7
category c557;
#line 7
category c558;
#line 7
category c559;
#line 7
category c560;
#line 7
category c561;
#line 7
category c562;
#line 7
category c563;
#line 7
category c564;
#line 7
category c565;
#line 7
category c566;
#line 7
category c567;
#line 7
category c568;
#line 7
category c569;
#line 7
category c570;
#line 7
category c571;
#line 7
category c572;
#line 7
category c573;
#line 7
category c574;
#line 7
category c575;
#line 7
category c576;
#line 7
category c577;
#line 7
category c578;
#line 7
category c579;
#line 7
category c580;
#line 7
category c581;
#line 7
category c582;
#line 7
category c583;
#line 7
category c584;
#line 7
category c585;
#line 7
category c586;
#line 7
category c587;
#line 7
category c588;
#line 7
category c589;
#line 7
category c590;
#line 7
category c591;
#line 7
category c592;
#line 7
category c593;
#line 7
category c594;
#line 7
category c595;
#line 7
category c596;
#line 7
category c597;
#line 7
category c598;
#line 7
category c599;
#line 7
category c600;
#line 7
category c601;
#line 7
category c602;
#line 7
category c603;
#line 7
category c604;
#line 7
category c605;
#line 7
category c606;
#line 7
category c607;
#line 7
category c608;
#line 7
category c609;
#line 7
category c610;
#line 7
category c611;
#line 7
category c612;
#line 7
category c613;
#line 7
category c614;
#line 7
category c615;
#line 7
category c616;
#line 7
category c617;
#line 7
category c618;
#line 7
category c619;
#line 7
category c620;
#line 7
category c621;
#line 7
category c622;
#line 7
category c623;
#line 7
category c624;
#line 7
category c625;
#line 7
category c626;
#line 7
category c627;
#line 7
category c628;
#line 7
category c629;
#line 7
category c630;
#line 7
category c631;
#line 7
category c632;
#line 7
category c633;
#line 7
category c634;
#line 7
category c635;
#line 7
category c636;
#line 7
category c637;
#line 7
category c638;
#line 7
category c639;
#line 7
category c640;
#line 7
category c641;
#line 7
category c642;
#line 7
category c643;
#line 7
category c644;
#line 7
category c645;
#line 7
category c646;
#line 7
category c647;
#line 7
category c648;
#line 7
category c649;
#line 7
category c650;
#line 7
category c651;
#line 7
category c652;
#line 7
category c653;
#line 7
category c654;
#line 7
category c655;
#line 7
category c656;
#line 7
category c657;
#line 7
category c658;
#line 7
category c659;
#line 7
category c660;
#line 7
category c661;
#line 7
category c662;
#line 7
category c663;
#line 7
category c664;
#line 7
category c665;
#line 7
category c666;
#line 7
category c667;
#line 7
category c668;
#line 7
category c669;
#line 7
category c670;
#line 7
category c671;
#line 7
category c672;
#line 7
category c673;
#line 7
category c674;
#line 7
category c675;
#line 7
category c676;
#line 7
category c677;
#line 7
category c678;
#line 7
category c679;
#line 7
category c680;
#line 7
category c681;
#line 7
category c682;
#line 7
category c683;
#line 7
category c684;
#line 7
category c685;
#line 7
category c686;
#line 7
category c687;
#line 7
category c688;
#line 7
category c689;
#line 7
category c690;
#line 7
category c691;
#line 7
category c692;
#line 7
category c693;
#line 7
category c694;
#line 7
category c695;
#line 7
category c696;
#line 7
category c697;
#line 7
category c698;
#line 7
category c699;
#line 7
category c700;
#line 7
category c701;
#line 7
category c702;
#line 7
category c703;
#line 7
category c704;
#line 7
category c705;
#line 7
category c706;
#line 7
category c707;
#line 7
category c708;
#line 7
category c709;
#line 7
category c710;
#line 7
category c711;
#line 7
category c712;
#line 7
category c713;
#line 7
category c714;
#line 7
category c715;
#line 7
category c716;
#line 7
category c717;
#line 7
category c718;
#line 7
category c719;
#line 7
category c720;
#line 7
category c721;
#line 7
category c722;
#line 7
category c723;
#line 7
category c724;
#line 7
category c725;
#line 7
category c726;
#line 7
category c727;
#line 7
category c728;
#line 7
category c729;
#line 7
category c730;
#line 7
category c731;
#line 7
category c732;
#line 7
category c733;
#line 7
category c734;
#line 7
category c735;
#line 7
category c736;
#line 7
category c737;
#line 7
category c738;
#line 7
category c739;
#line 7
category c740;
#line 7
category c741;
#line 7
category c742;
#line 7
category c743;
#line 7
category c744;
#line 7
category c745;
#line 7
category c746;
#line 7
category c747;
#line 7
category c748;
#line 7
category c749;
#line 7
category c750;
#line 7
category c751;
#line 7
category c752;
#line 7
category c753;
#line 7
category c754;
#line 7
category c755;
#line 7
category c756;
#line 7
category c757;
#line 7
category c758;
#line 7
category c759;
#line 7
category c760;
#line 7
category c761;
#line 7
category c762;
#line 7
category c763;
#line 7
category c764;
#line 7
category c765;
#line 7
category c766;
#line 7
category c767;
#line 7
category c768;
#line 7
category c769;
#line 7
category c770;
#line 7
category c771;
#line 7
category c772;
#line 7
category c773;
#line 7
category c774;
#line 7
category c775;
#line 7
category c776;
#line 7
category c777;
#line 7
category c778;
#line 7
category c779;
#line 7
category c780;
#line 7
category c781;
#line 7
category c782;
#line 7
category c783;
#line 7
category c784;
#line 7
category c785;
#line 7
category c786;
#line 7
category c787;
#line 7
category c788;
#line 7
category c789;
#line 7
category c790;
#line 7
category c791;
#line 7
category c792;
#line 7
category c793;
#line 7
category c794;
#line 7
category c795;
#line 7
category c796;
#line 7
category c797;
#line 7
category c798;
#line 7
category c799;
#line 7
category c800;
#line 7
category c801;
#line 7
category c802;
#line 7
category c803;
#line 7
category c804;
#line 7
category c805;
#line 7
category c806;
#line 7
category c807;
#line 7
category c808;
#line 7
category c809;
#line 7
category c810;
#line 7
category c811;
#line 7
category c812;
#line 7
category c813;
#line 7
category c814;
#line 7
category c815;
#line 7
category c816;
#line 7
category c817;
#line 7
category c818;
#line 7
category c819;
#line 7
category c820;
#line 7
category c821;
#line 7
category c822;
#line 7
category c823;
#line 7
category c824;
#line 7
category c825;
#line 7
category c826;
#line 7
category c827;
#line 7
category c828;
#line 7
category c829;
#line 7
category c830;
#line 7
category c831;
#line 7
category c832;
#line 7
category c833;
#line 7
category c834;
#line 7
category c835;
#line 7
category c836;
#line 7
category c837;
#line 7
category c838;
#line 7
category c839;
#line 7
category c840;
#line 7
category c841;
#line 7
category c842;
#line 7
category c843;
#line 7
category c844;
#line 7
category c845;
#line 7
category c846;
#line 7
category c847;
#line 7
category c848;
#line 7
category c849;
#line 7
category c850;
#line 7
category c851;
#line 7
category c852;
#line 7
category c853;
#line 7
category c854;
#line 7
category c855;
#line 7
category c856;
#line 7
category c857;
#line 7
category c858;
#line 7
category c859;
#line 7
category c860;
#line 7
category c861;
#line 7
category c862;
#line 7
category c863;
#line 7
category c864;
#line 7
category c865;
#line 7
category c866;
#line 7
category c867;
#line 7
category c868;
#line 7
category c869;
#line 7
category c870;
#line 7
category c871;
#line 7
category c872;
#line 7
category c873;
#line 7
category c874;
#line 7
category c875;
#line 7
category c876;
#line 7
category c877;
#line 7
category c878;
#line 7
category c879;
#line 7
category c880;
#line 7
category c881;
#line 7
category c882;
#line 7
category c883;
#line 7
category c884;
#line 7
category c885;
#line 7
category c886;
#line 7
category c887;
#line 7
category c888;
#line 7
category c889;
#line 7
category c890;
#line 7
category c891;
#line 7
category c892;
#line 7
category c893;
#line 7
category c894;
#line 7
category c895;
#line 7
category c896;
#line 7
category c897;
#line 7
category c898;
#line 7
category c899;
#line 7
category c900;
#line 7
category c901;
#line 7
category c902;
#line 7
category c903;
#line 7
category c904;
#line 7
category c905;
#line 7
category c906;
#line 7
category c907;
#line 7
category c908;
#line 7
category c909;
#line 7
category c910;
#line 7
category c911;
#line 7
category c912;
#line 7
category c913;
#line 7
category c914;
#line 7
category c915;
#line 7
category c916;
#line 7
category c917;
#line 7
category c918;
#line 7
category c919;
#line 7
category c920;
#line 7
category c921;
#line 7
category c922;
#line 7
category c923;
#line 7
category c924;
#line 7
category c925;
#line 7
category c926;
#line 7
category c927;
#line 7
category c928;
#line 7
category c929;
#line 7
category c930;
#line 7
category c931;
#line 7
category c932;
#line 7
category c933;
#line 7
category c934;
#line 7
category c935;
#line 7
category c936;
#line 7
category c937;
#line 7
category c938;
#line 7
category c939;
#line 7
category c940;
#line 7
category c941;
#line 7
category c942;
#line 7
category c943;
#line 7
category c944;
#line 7
category c945;
#line 7
category c946;
#line 7
category c947;
#line 7
category c948;
#line 7
category c949;
#line 7
category c950;
#line 7
category c951;
#line 7
category c952;
#line 7
category c953;
#line 7
category c954;
#line 7
category c955;
#line 7
category c956;
#line 7
category c957;
#line 7
category c958;
#line 7
category c959;
#line 7
category c960;
#line 7
category c961;
#line 7
category c962;
#line 7
category c963;
#line 7
category c964;
#line 7
category c965;
#line 7
category c966;
#line 7
category c967;
#line 7
category c968;
#line 7
category c969;
#line 7
category c970;
#line 7
category c971;
#line 7
category c972;
#line 7
category c973;
#line 7
category c974;
#line 7
category c975;
#line 7
category c976;
#line 7
category c977;
#line 7
category c978;
#line 7
category c979;
#line 7
category c980;
#line 7
category c981;
#line 7
category c982;
#line 7
category c983;
#line 7
category c984;
#line 7
category c985;
#line 7
category c986;
#line 7
category c987;
#line 7
category c988;
#line 7
category c989;
#line 7
category c990;
#line 7
category c991;
#line 7
category c992;
#line 7
category c993;
#line 7
category c994;
#line 7
category c995;
#line 7
category c996;
#line 7
category c997;
#line 7
category c998;
#line 7
category c999;
#line 7
category c1000;
#line 7
category c1001;
#line 7
category c1002;
#line 7
category c1003;
#line 7
category c1004;
#line 7
category c1005;
#line 7
category c1006;
#line 7
category c1007;
#line 7
category c1008;
#line 7
category c1009;
#line 7
category c1010;
#line 7
category c1011;
#line 7
category c1012;
#line 7
category c1013;
#line 7
category c1014;
#line 7
category c1015;
#line 7
category c1016;
#line 7
category c1017;
#line 7
category c1018;
#line 7
category c1019;
#line 7
category c1020;
#line 7
category c1021;
#line 7
category c1022;
#line 7
category c1023;
#line 7


# Generate level definitions for each sensitivity and category.
level s0:c0.c1023;
#line 10



#################################################
# MLS policy constraints
#

#
# Process constraints
#

# Process transition:  Require equivalence unless the subject is trusted.
mlsconstrain process { transition dyntransition }
	     ((h1 eq h2 and l1 eq l2) or t1 == mlstrustedsubject);

# Process read operations: No read up unless trusted.
mlsconstrain process { getsched getsession getpgid getcap getattr ptrace share }
	     (l1 dom l2 or t1 == mlstrustedsubject);

# Process write operations:  No write down unless trusted.
mlsconstrain process { sigkill sigstop signal setsched setpgid setcap setrlimit ptrace share }
	     (l1 domby l2 or t1 == mlstrustedsubject);

#
# Socket constraints
#

# Create/relabel operations:  Subject must be equivalent to object unless
# the subject is trusted.  Sockets inherit the range of their creator.
mlsconstrain { socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket } { create relabelfrom relabelto }
	     ((h1 eq h2 and l1 eq l2) or t1 == mlstrustedsubject);

# Datagram send: Sender must be dominated by receiver unless one of them is
# trusted.
mlsconstrain unix_dgram_socket { sendto }
	     (l1 domby l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);

# Stream connect:  Client must be equivalent to server unless one of them
# is trusted.
mlsconstrain unix_stream_socket { connectto }
	     (l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);

#
# Directory/file constraints
#

# Create/relabel operations:  Subject must be equivalent to object unless
# the subject is trusted. Also, files should always be single-level.
# Do NOT exempt mlstrustedobject types from this constraint.
mlsconstrain { dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } { create relabelfrom relabelto }
	     (l2 eq h2 and (l1 eq l2 or t1 == mlstrustedsubject));

# Read operations: Subject must dominate object unless the subject
# or the object is trusted.
mlsconstrain dir { read getattr search }
	     (l1 dom l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject);

mlsconstrain { file lnk_file sock_file chr_file blk_file } { read getattr execute }
	     (l1 dom l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject);

# Write operations: Subject must be dominated by the object unless the
# subject or the object is trusted.
mlsconstrain dir { write setattr rename add_name remove_name reparent rmdir }
	     (l1 domby l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject);

mlsconstrain { file lnk_file sock_file chr_file blk_file } { write setattr append unlink link rename }
	     (l1 domby l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject);

# Special case for FIFOs.
# These can be unnamed pipes, in which case they will be labeled with the
# creating process' label. Thus we also have an exemption when the "object"
# is a MLS trusted subject and can receive data at any level.
mlsconstrain fifo_file { read getattr }
	     (l1 dom l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject or t2 == mlstrustedsubject);

mlsconstrain fifo_file { write setattr append unlink link rename }
	     (l1 domby l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject or t2 == mlstrustedsubject);

#
# IPC constraints
#

# Create/destroy: equivalence or trusted.
mlsconstrain { sem msgq shm ipc } { create destroy }
	     (l2 eq h2 and (l1 eq l2 or t1 == mlstrustedsubject));

# Read ops: No read up unless trusted.
mlsconstrain { sem msgq shm ipc } { getattr read associate unix_read }
	     (l1 dom l2 or t1 == mlstrustedsubject);

# Write ops: No write down unless trusted.
mlsconstrain { sem msgq shm ipc } { write unix_write }
	     (l1 domby l2 or t1 == mlstrustedsubject);

#
# Binder IPC constraints
#
# Presently commented out, as apps are expected to call one another.
# This would only make sense if apps were assigned categories
# based on allowable communications rather than per-app categories.
#mlsconstrain binder call
#	(l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);
#line 1 "external/sepolicy/policy_capabilities"
# Enable new networking controls.
policycap network_peer_controls;

# Enable open permission check.
policycap open_perms;
#line 1 "external/sepolicy/te_macros"
#####################################
# domain_trans(olddomain, type, newdomain)
# Allow a transition from olddomain to newdomain
# upon executing a file labeled with type.
# This only allows the transition; it does not
# cause it to occur automatically - use domain_auto_trans
# if that is what you want.
#
#line 21


#####################################
# domain_auto_trans(olddomain, type, newdomain)
# Automatically transition from olddomain to newdomain
# upon executing a file labeled with type.
#
#line 33


#####################################
# file_type_trans(domain, dir_type, file_type)
# Allow domain to create a file labeled file_type in a
# directory labeled dir_type.
# This only allows the transition; it does not
# cause it to occur automatically - use file_type_auto_trans
# if that is what you want.
#
#line 49


#####################################
# file_type_auto_trans(domain, dir_type, file_type)
# Automatically label new files with file_type when
# they are created by domain in directories labeled dir_type.
#
#line 62


#####################################
# r_dir_file(domain, type)
# Allow the specified domain to read directories, files
# and symbolic links of the specified type.
#line 71


#####################################
# unconfined_domain(domain)
# Allow the specified domain to perform more privileged operations
# than would be typically allowed. Please see the comments at the
# top of unconfined.te.
#
#line 82


#####################################
# tmpfs_domain(domain)
# Define and allow access to a unique type for
# this domain when creating tmpfs / shmem / ashmem files.
#line 92


#####################################
# init_daemon_domain(domain)
# Set up a transition from init to the daemon domain
# upon executing its binary.
#line 101


#####################################
# app_domain(domain)
# Allow a base set of permissions required for all apps.
#line 112


#####################################
# net_domain(domain)
# Allow a base set of permissions required for network access.
#line 119


#####################################
# bluetooth_domain(domain)
# Allow a base set of permissions required for bluetooth access.
#line 126


#####################################
# unix_socket_connect(clientdomain, socket, serverdomain)
# Allow a local socket connection from clientdomain via
# socket to serverdomain.
#line 135


#####################################
# unix_socket_send(clientdomain, socket, serverdomain)
# Allow a local socket send from clientdomain via
# socket to serverdomain.
#line 144


#####################################
# binder_use(domain)
# Allow domain to use Binder IPC.
#line 158


#####################################
# binder_call(clientdomain, serverdomain)
# Allow clientdomain to perform binder IPC to serverdomain.
#line 170


#####################################
# binder_service(domain)
# Mark a domain as being a Binder service domain.
# Used to allow binder IPC to the various system services.
#line 178


#####################################
# wakelock_use(domain)
# Allow domain to manage wake locks
#line 188


#####################################
# selinux_check_access(domain)
# Allow domain to check SELinux permissions via selinuxfs.
#line 197


#####################################
# selinux_check_context(domain)
# Allow domain to check SELinux contexts via selinuxfs.
#line 205


#####################################
# selinux_setenforce(domain)
# Allow domain to set SELinux to enforcing.
#line 213


#####################################
# selinux_setbool(domain)
# Allow domain to set SELinux booleans.
#line 221


#####################################
# security_access_policy(domain)
# Read only access to all policy files and
# selinuxfs
#line 230


#####################################
# selinux_manage_policy(domain)
# Ability to manage policy files and
# trigger runtime reload.
#line 243


#####################################
# mmac_manage_policy(domain)
# Ability to manage mmac policy files,
# trigger runtime reload, change
# mmac enforcing mode and access logcat.
#line 256


#####################################
# access_kmsg(domain)
# Ability to read from kernel logs
# and execute the klogctl syscall
# in a non destructive manner. See
# man 2 klogctl
#line 266


#####################################
# write_klog(domain)
# Ability to write to kernel log via
# klog_write()
# See system/core/libcutil/klog.c
#line 277


#####################################
# create_pty(domain)
# Allow domain to create and use a pty, isolated from any other domain ptys.
#line 291


#####################################
# Non system_app application set
#


#####################################
# Recovery only
# SELinux rules which apply only to recovery mode
#


#####################################
# Bootchart
# SELinux rules which apply only to bootchart builds
#


#####################################
# Userdebug or eng builds
# SELinux rules which apply only to userdebug or eng builds
#


#####################################
# permissive_or_unconfined
# Returns "permissive $1" if FORCE_PERMISSIVE_TO_UNCONFINED is false,
# and "unconfined($1)" otherwise.
#
# This is used for experimental domains, where we want to ensure
# the domain is unconfined+enforcing once new SELinux policy development
# has ceased.
#


#####################################
# write_logd(domain)
# Ability to write to android log
# daemon via sockets
#line 336


#####################################
# read_logd(domain)
# Ability to read from android
# log daemon via sockets
#line 344


#####################################
# control_logd(domain)
# Ability to control
# android log daemon via sockets
#line 354


#####################################
# use_keystore(domain)
# Ability to use keystore.
# Keystore is requires the following permissions
# to call getpidcon.
#line 366

#line 1 "external/sepolicy/attributes"
######################################
# Attribute declarations
#

# All types used for devices.
attribute dev_type;

# All types used for processes.
attribute domain;

# All types used for filesystems.
attribute fs_type;

# All types used for context= mounts.
attribute contextmount_type;

# All types used for files that can exist on a labeled fs.
# Do not use for pseudo file types.
attribute file_type;

# All types used for domain entry points.
attribute exec_type;

# All types used for /data files.
attribute data_file_type;

# All types use for sysfs files.
attribute sysfs_type;

# Attribute used for all sdcards
attribute sdcard_type;

# All types used for nodes/hosts.
attribute node_type;

# All types used for network interfaces.
attribute netif_type;

# All types used for network ports.
attribute port_type;

# All types used for property service
attribute property_type;

# All types used for services managed by service_manager.
attribute service_manager_type;

# All domains that can override MLS restrictions.
# i.e. processes that can read up and write down.
attribute mlstrustedsubject;

# All types that can override MLS restrictions.
# i.e. files that can be read by lower and written by higher
attribute mlstrustedobject;

# Domains that are allowed all permissions ("unconfined").
attribute unconfineddomain;

# All domains used for apps.
attribute appdomain;

# All domains used for apps with network access.
attribute netdomain;

# All domains used for apps with bluetooth access.
attribute bluetoothdomain;

# All domains used for binder service domains.
attribute binderservicedomain;
#line 1 "external/sepolicy/dnsmasq.te"
# DNS, DHCP services
type dnsmasq, domain;
type dnsmasq_exec, exec_type, file_type;


#line 5
typeattribute dnsmasq netdomain;
#line 5


# TODO:  Run with dhcp group to avoid need for dac_override.
allow dnsmasq self:capability dac_override;

allow dnsmasq self:capability { net_admin net_raw net_bind_service setgid setuid };

allow dnsmasq dhcp_data_file:dir { open search write add_name remove_name };
allow dnsmasq dhcp_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Inherit and use open files from netd.
allow dnsmasq netd:fd use;
allow dnsmasq netd:fifo_file { read write };
# TODO: Investigate whether these inherited sockets should be closed on exec.
allow dnsmasq netd:netlink_kobject_uevent_socket { read write };
allow dnsmasq netd:netlink_nflog_socket { read write };
allow dnsmasq netd:netlink_route_socket { read write };
allow dnsmasq netd:unix_stream_socket { read write };
allow dnsmasq netd:unix_dgram_socket { read write };
allow dnsmasq netd:udp_socket { read write };
#line 1 "external/sepolicy/sdcardd.te"
type sdcardd, domain;
type sdcardd_exec, exec_type, file_type;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init sdcardd_exec:file { getattr open read execute };
#line 4
allow init sdcardd:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow sdcardd sdcardd_exec:file { entrypoint open read execute getattr };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4
allow sdcardd init:process sigchld;
#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init sdcardd:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init sdcardd:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init sdcardd_exec:process sdcardd;
#line 4

#line 4

#line 4
type sdcardd_tmpfs, file_type;
#line 4
type_transition sdcardd tmpfs:file sdcardd_tmpfs;
#line 4
allow sdcardd sdcardd_tmpfs:file { read write };
#line 4

#line 4


allow sdcardd cgroup:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow sdcardd fuse_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow sdcardd rootfs:dir mounton;
allow sdcardd sdcard_type:filesystem { mount unmount };
allow sdcardd self:capability { setuid setgid dac_override sys_admin sys_resource };

allow sdcardd sdcard_type:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow sdcardd sdcard_type:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

type_transition sdcardd system_data_file:{ dir file } media_rw_data_file;
allow sdcardd media_rw_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow sdcardd media_rw_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Read /data/system/packages.list.
allow sdcardd system_data_file:file { getattr open read ioctl lock };

# Read /data/.layout_version
allow sdcardd install_data_file:file { getattr open read ioctl lock };
#line 1 "external/sepolicy/kernel.te"
# Life begins with the kernel.
type kernel, domain;

# Run /init before we have switched domains.
allow kernel rootfs:file execute_no_trans;

# setcon to init domain.
allow kernel self:process setcurrent;
allow kernel init:process dyntransition;

# The kernel is unconfined.

#line 12
typeattribute kernel mlstrustedsubject;
#line 12
typeattribute kernel unconfineddomain;
#line 12


# cgroup filesystem initialization prior to setting the cgroup root directory label.
allow kernel unlabeled:dir search;

# Mount usbfs.
allow kernel usbfs:filesystem mount;

# init direct restorecon calls prior to switching to init domain
# /dev and /dev/socket
allow kernel { device socket_device }:dir relabelto;
# /dev/__properties__
allow kernel properties_device:file relabelto;
# /sys
allow kernel sysfs:{ dir file lnk_file } relabelfrom;
allow kernel sysfs_type:{ dir file lnk_file } relabelto;

# Initial setenforce by init prior to switching to init domain.
# We use dontaudit instead of allow to prevent a kernel spawned userspace
# process from turning off SELinux once enabled.
dontaudit kernel self:security setenforce;

# Set checkreqprot by init.rc prior to switching to init domain.
allow kernel self:security setcheckreqprot;

# MTP sync (b/15835289)
# kernel thread "loop0", used by the loop block device, for ASECs (b/17158723)
allow kernel sdcard_type:file { read write };

# Allow the kernel to read OBB files from app directories. (b/17428116)
# Kernel thread "loop0" reads a vold supplied file descriptor.
# Fixes CTS tests:
#  * android.os.storage.cts.StorageManagerTest#testMountAndUnmountObbNormal
#  * android.os.storage.cts.StorageManagerTest#testMountAndUnmountTwoObbs
allow kernel app_data_file:file read;

###
### neverallow rules
###

# The initial task starts in the kernel domain (assigned via
# initial_sid_contexts), but nothing ever transitions to it.
neverallow domain kernel:process { transition dyntransition };

# The kernel domain is never entered via an exec, nor should it
# ever execute a program outside the rootfs without changing to another domain.
# If you encounter an execute_no_trans denial on the kernel domain, then
# possible causes include:
# - The program is a kernel usermodehelper.  In this case, define a domain
#   for the program and domain_auto_trans() to it.
# - You failed to setcon u:r:init:s0 in your init.rc and thus your init
#   program was left in the kernel domain and is now trying to execute
#   some other program.  Fix your init.rc file.
# - You are running an exploit which switched to the init task credentials
#   and is then trying to exec a shell or other program.  You lose!
neverallow kernel { file_type fs_type -rootfs }:file { entrypoint execute_no_trans };

# For UMS full-device exports
allow kernel block_device:blk_file { getattr open read ioctl lock };
#line 1 "external/sepolicy/platform_app.te"
###
### Apps signed with the platform key.
###

type platform_app, domain;

#line 6
typeattribute platform_app appdomain;
#line 6
# Label ashmem objects with our own unique type.
#line 6

#line 6
type platform_app_tmpfs, file_type;
#line 6
type_transition platform_app tmpfs:file platform_app_tmpfs;
#line 6
allow platform_app platform_app_tmpfs:file { read write };
#line 6

#line 6
# Map with PROT_EXEC.
#line 6
allow platform_app platform_app_tmpfs:file execute;
#line 6

# Access the network.

#line 8
typeattribute platform_app netdomain;
#line 8

# Access bluetooth.

#line 10
typeattribute platform_app bluetoothdomain;
#line 10

# Read from /data/local/tmp or /data/data/com.android.shell.
allow platform_app shell_data_file:dir search;
allow platform_app shell_data_file:file { open getattr read };
# Populate /data/app/vmdl*.tmp, /data/app-private/vmdl*.tmp files
# created by system server.
allow platform_app { apk_tmp_file apk_private_tmp_file }:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow platform_app { apk_tmp_file apk_private_tmp_file }:file { { getattr open read ioctl lock } { open append write } };
allow platform_app apk_private_data_file:dir search;
# ASEC
allow platform_app asec_apk_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow platform_app asec_apk_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Access to /data/media.
allow platform_app media_rw_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow platform_app media_rw_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Write to /cache.
allow platform_app cache_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow platform_app cache_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
#line 1 "external/sepolicy/inputflinger.te"
# inputflinger
type inputflinger, domain;
type inputflinger_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init inputflinger_exec:file { getattr open read execute };
#line 5
allow init inputflinger:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow inputflinger inputflinger_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow inputflinger init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init inputflinger:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init inputflinger:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init inputflinger_exec:process inputflinger;
#line 5

#line 5

#line 5
type inputflinger_tmpfs, file_type;
#line 5
type_transition inputflinger tmpfs:file inputflinger_tmpfs;
#line 5
allow inputflinger inputflinger_tmpfs:file { read write };
#line 5

#line 5


#line 6
# Call the servicemanager and transfer references to it.
#line 6
allow inputflinger servicemanager:binder { call transfer };
#line 6
# servicemanager performs getpidcon on clients.
#line 6
allow servicemanager inputflinger:dir search;
#line 6
allow servicemanager inputflinger:file { read open };
#line 6
allow servicemanager inputflinger:process getattr;
#line 6
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 6
# all domains in domain.te.
#line 6


#line 7
typeattribute inputflinger binderservicedomain;
#line 7



#line 9
# Call the server domain and optionally transfer references to it.
#line 9
allow inputflinger system_server:binder { call transfer };
#line 9
# Allow the serverdomain to transfer references to the client on the reply.
#line 9
allow system_server inputflinger:binder transfer;
#line 9
# Receive and use open files from the server.
#line 9
allow inputflinger system_server:fd use;
#line 9


allow inputflinger inputflinger_service:service_manager add;
#line 1 "external/sepolicy/mediaserver.te"
# mediaserver - multimedia daemon
type mediaserver, domain;
type mediaserver_exec, exec_type, file_type;

typeattribute mediaserver mlstrustedsubject;


#line 7
typeattribute mediaserver netdomain;
#line 7


#line 8

#line 8
# Allow the necessary permissions.
#line 8

#line 8
# Old domain may exec the file and transition to the new domain.
#line 8
allow init mediaserver_exec:file { getattr open read execute };
#line 8
allow init mediaserver:process transition;
#line 8
# New domain is entered by executing the file.
#line 8
allow mediaserver mediaserver_exec:file { entrypoint open read execute getattr };
#line 8
# New domain can send SIGCHLD to its caller.
#line 8
allow mediaserver init:process sigchld;
#line 8
# Enable AT_SECURE, i.e. libc secure mode.
#line 8
dontaudit init mediaserver:process noatsecure;
#line 8
# XXX dontaudit candidate but requires further study.
#line 8
allow init mediaserver:process { siginh rlimitinh };
#line 8

#line 8
# Make the transition occur by default.
#line 8
type_transition init mediaserver_exec:process mediaserver;
#line 8

#line 8

#line 8
type mediaserver_tmpfs, file_type;
#line 8
type_transition mediaserver tmpfs:file mediaserver_tmpfs;
#line 8
allow mediaserver mediaserver_tmpfs:file { read write };
#line 8

#line 8


#line 9
allow mediaserver property_socket:sock_file write;
#line 9
allow mediaserver init:unix_stream_socket connectto;
#line 9



#line 11
allow mediaserver sdcard_type:dir { open getattr read search ioctl };
#line 11
allow mediaserver sdcard_type:{ file lnk_file } { getattr open read ioctl lock };
#line 11



#line 13
# Call the servicemanager and transfer references to it.
#line 13
allow mediaserver servicemanager:binder { call transfer };
#line 13
# servicemanager performs getpidcon on clients.
#line 13
allow servicemanager mediaserver:dir search;
#line 13
allow servicemanager mediaserver:file { read open };
#line 13
allow servicemanager mediaserver:process getattr;
#line 13
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 13
# all domains in domain.te.
#line 13


#line 14
# Call the server domain and optionally transfer references to it.
#line 14
allow mediaserver binderservicedomain:binder { call transfer };
#line 14
# Allow the serverdomain to transfer references to the client on the reply.
#line 14
allow binderservicedomain mediaserver:binder transfer;
#line 14
# Receive and use open files from the server.
#line 14
allow mediaserver binderservicedomain:fd use;
#line 14


#line 15
# Call the server domain and optionally transfer references to it.
#line 15
allow mediaserver appdomain:binder { call transfer };
#line 15
# Allow the serverdomain to transfer references to the client on the reply.
#line 15
allow appdomain mediaserver:binder transfer;
#line 15
# Receive and use open files from the server.
#line 15
allow mediaserver appdomain:fd use;
#line 15


#line 16
typeattribute mediaserver binderservicedomain;
#line 16


allow mediaserver self:process execmem;
allow mediaserver kernel:system module_request;
allow mediaserver media_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow mediaserver media_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow mediaserver app_data_file:dir search;
allow mediaserver app_data_file:file { { getattr open read ioctl lock } { open append write } };
allow mediaserver sdcard_type:file write;
allow mediaserver gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow mediaserver video_device:dir { open getattr read search ioctl };
allow mediaserver video_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow mediaserver audio_device:dir { open getattr read search ioctl };
allow mediaserver tee_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow mediaserver audio_prop:property_service set;

# Access audio devices at all.
allow mediaserver audio_device:chr_file { { getattr open read ioctl lock } { open append write } };

# XXX Label with a specific type?
allow mediaserver sysfs:file { { getattr open read ioctl lock } { open append write } };

# Read resources from open apk files passed over Binder.
allow mediaserver apk_data_file:file { read getattr };
allow mediaserver asec_apk_file:file { read getattr };

# Read /data/data/com.android.providers.telephony files passed over Binder.
allow mediaserver radio_data_file:file { read getattr };

# Use pipes passed over Binder from app domains.
allow mediaserver appdomain:fifo_file { getattr read write };

# Access camera device.
allow mediaserver camera_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow mediaserver rpmsg_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Inter System processes communicate over named pipe (FIFO)
allow mediaserver system_server:fifo_file { getattr open read ioctl lock };

# Camera data

#line 56
allow mediaserver camera_data_file:dir { open getattr read search ioctl };
#line 56
allow mediaserver camera_data_file:{ file lnk_file } { getattr open read ioctl lock };
#line 56


#line 57
allow mediaserver media_rw_data_file:dir { open getattr read search ioctl };
#line 57
allow mediaserver media_rw_data_file:{ file lnk_file } { getattr open read ioctl lock };
#line 57


# Grant access to audio files to mediaserver
allow mediaserver audio_data_file:dir { { open getattr read search ioctl } add_name write };
allow mediaserver audio_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Read/[write] to /proc/net/xt_qtaguid/ctrl and /dev/xt_qtaguid
allow mediaserver qtaguid_proc:file { { getattr open read ioctl lock } { open append write } };
allow mediaserver qtaguid_device:chr_file { getattr open read ioctl lock };

# Allow abstract socket connection
allow mediaserver rild:unix_stream_socket { connectto read write setopt };

# Needed on some devices for playing DRM protected content,
# but seems expected and appropriate for all devices.

#line 72
allow mediaserver drmserver_socket:sock_file write;
#line 72
allow mediaserver drmserver:unix_stream_socket connectto;
#line 72


# Needed on some devices for playing audio on paired BT device,
# but seems appropriate for all devices.

#line 76
allow mediaserver bluetooth_socket:sock_file write;
#line 76
allow mediaserver bluetooth:unix_stream_socket connectto;
#line 76


# Connect to tee service.
allow mediaserver tee:unix_stream_socket connectto;

allow mediaserver mediaserver_service:service_manager add;

# /oem access
allow mediaserver oemfs:dir search;
allow mediaserver oemfs:file { getattr open read ioctl lock };

allow mediaserver bootanim:binder { transfer call };
#line 1 "external/sepolicy/lmkd.te"
# lmkd low memory killer daemon
type lmkd, domain;
type lmkd_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init lmkd_exec:file { getattr open read execute };
#line 5
allow init lmkd:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow lmkd lmkd_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow lmkd init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init lmkd:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init lmkd:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init lmkd_exec:process lmkd;
#line 5

#line 5

#line 5
type lmkd_tmpfs, file_type;
#line 5
type_transition lmkd tmpfs:file lmkd_tmpfs;
#line 5
allow lmkd lmkd_tmpfs:file { read write };
#line 5

#line 5


allow lmkd self:capability { dac_override sys_resource kill };

# lmkd locks itself in memory, to prevent it from being
# swapped out and unable to kill other memory hogs.
# system/core commit b28ff9131363f7b4a698990da5748b2a88c3ed35
# b/16236289
allow lmkd self:capability ipc_lock;

## Open and write to /proc/PID/oom_score_adj
## TODO: maybe scope this down?

#line 17
allow lmkd appdomain:dir { open getattr read search ioctl };
#line 17
allow lmkd appdomain:{ file lnk_file } { getattr open read ioctl lock };
#line 17

allow lmkd appdomain:file write;

#line 19
allow lmkd system_server:dir { open getattr read search ioctl };
#line 19
allow lmkd system_server:{ file lnk_file } { getattr open read ioctl lock };
#line 19

allow lmkd system_server:file write;

## Writes to /sys/module/lowmemorykiller/parameters/minfree
allow lmkd sysfs_lowmemorykiller:file { open append write };

# Send kill signals
allow lmkd appdomain:process sigkill;

# Clean up old cgroups
allow lmkd cgroup:dir { remove_name rmdir };

# Set self to SCHED_FIFO
allow lmkd self:capability sys_nice;

### neverallow rules

# never honor LD_PRELOAD
neverallow domain lmkd:process noatsecure;
#line 1 "external/sepolicy/rild.te"
# rild - radio interface layer daemon
type rild, domain;
type rild_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init rild_exec:file { getattr open read execute };
#line 5
allow init rild:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow rild rild_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow rild init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init rild:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init rild:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init rild_exec:process rild;
#line 5

#line 5

#line 5
type rild_tmpfs, file_type;
#line 5
type_transition rild tmpfs:file rild_tmpfs;
#line 5
allow rild rild_tmpfs:file { read write };
#line 5

#line 5


#line 6
typeattribute rild netdomain;
#line 6

allow rild self:netlink_route_socket nlmsg_write;
allow rild kernel:system module_request;

#line 9
allow rild property_socket:sock_file write;
#line 9
allow rild init:unix_stream_socket connectto;
#line 9

allow rild self:capability { setuid net_admin net_raw };
allow rild alarm_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow rild cgroup:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow rild radio_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow rild radio_device:blk_file { getattr open read ioctl lock };
allow rild mtd_device:dir search;
allow rild efs_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow rild efs_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow rild shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow rild bluetooth_efs_file:file { getattr open read ioctl lock };
allow rild bluetooth_efs_file:dir { open getattr read search ioctl };
allow rild radio_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow rild radio_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow rild sdcard_type:dir { open getattr read search ioctl };
allow rild system_data_file:dir { open getattr read search ioctl };
allow rild system_data_file:file { getattr open read ioctl lock };
allow rild system_file:file { getattr execute execute_no_trans };

# property service
allow rild radio_prop:property_service set;
allow rild net_radio_prop:property_service set;
allow rild system_radio_prop:property_service set;
auditallow rild net_radio_prop:property_service set;
auditallow rild system_radio_prop:property_service set;

# Read/Write to uart driver (for GPS)
allow rild gps_device:chr_file { { getattr open read ioctl lock } { open append write } };

allow rild tty_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Allow rild to create and use netlink sockets.
allow rild self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow rild self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Access to wake locks

#line 45
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 45
allow rild sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
#line 45
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 45
allow rild self:capability2 block_suspend;
#line 45


allow rild self:socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
#line 1 "external/sepolicy/clatd.te"
# 464xlat daemon
type clatd, domain;
type clatd_exec, exec_type, file_type;


#line 5
typeattribute clatd netdomain;
#line 5


# Access objects inherited from netd.
allow clatd netd:fd use;
allow clatd netd:fifo_file { read write };
# TODO: Check whether some or all of these sockets should be close-on-exec.
allow clatd netd:netlink_kobject_uevent_socket { read write };
allow clatd netd:netlink_nflog_socket { read write };
allow clatd netd:netlink_route_socket { read write };
allow clatd netd:udp_socket { read write };
allow clatd netd:unix_stream_socket { read write };
allow clatd netd:unix_dgram_socket { read write };

allow clatd self:capability { net_admin net_raw setuid setgid };

allow clatd self:netlink_route_socket nlmsg_write;
allow clatd self:{ packet_socket rawip_socket tun_socket } { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow clatd tun_device:chr_file { { getattr open read ioctl lock } { open append write } };
#line 1 "external/sepolicy/untrusted_app.te"
###
### Untrusted apps.
###
### This file defines the rules for untrusted apps.
### Apps are labeled based on mac_permissions.xml (maps signer and
### optionally package name to seinfo value) and seapp_contexts (maps UID
### and optionally seinfo value to domain for process and type for data
### directory).  The untrusted_app domain is the default assignment in
### seapp_contexts for any app with UID between APP_AID (10000)
### and AID_ISOLATED_START (99000) if the app has no specific seinfo
### value as determined from mac_permissions.xml.  In current AOSP, this
### domain is assigned to all non-system apps as well as to any system apps
### that are not signed by the platform key.  To move
### a system app into a specific domain, add a signer entry for it to
### mac_permissions.xml and assign it one of the pre-existing seinfo values
### or define and use a new seinfo value in both mac_permissions.xml and
### seapp_contexts.
###
### untrusted_app includes all the appdomain rules, plus the
### additional following rules:
###

type untrusted_app, domain;

#line 24
typeattribute untrusted_app appdomain;
#line 24
# Label ashmem objects with our own unique type.
#line 24

#line 24
type untrusted_app_tmpfs, file_type;
#line 24
type_transition untrusted_app tmpfs:file untrusted_app_tmpfs;
#line 24
allow untrusted_app untrusted_app_tmpfs:file { read write };
#line 24

#line 24
# Map with PROT_EXEC.
#line 24
allow untrusted_app untrusted_app_tmpfs:file execute;
#line 24


#line 25
typeattribute untrusted_app netdomain;
#line 25


#line 26
typeattribute untrusted_app bluetoothdomain;
#line 26


# Some apps ship with shared libraries and binaries that they write out
# to their sandbox directory and then execute.
allow untrusted_app app_data_file:file { { { getattr open read ioctl lock } { getattr execute execute_no_trans } } execmod };

allow untrusted_app tun_device:chr_file { { getattr open read ioctl lock } { open append write } };

# ASEC
allow untrusted_app asec_apk_file:file { getattr open read ioctl lock };
# Execute libs in asec containers.
allow untrusted_app asec_public_file:file { execute execmod };

# Allow the allocation and use of ptys
# Used by: https://play.google.com/store/apps/details?id=jackpal.androidterm

#line 41
# Each domain gets a unique devpts type.
#line 41
type untrusted_app_devpts, fs_type;
#line 41
# Label the pty with the unique type when created.
#line 41
type_transition untrusted_app devpts:chr_file untrusted_app_devpts;
#line 41
# Allow use of the pty after creation.
#line 41
allow untrusted_app untrusted_app_devpts:chr_file { open getattr read write ioctl };
#line 41
# Note: devpts:dir search and ptmx_device:chr_file rw_file_perms
#line 41
# allowed to everyone via domain.te.
#line 41


# Used by Finsky / Android "Verify Apps" functionality when
# running "adb install foo.apk".
# TODO: Long term, we don't want apps probing into shell data files.
# Figure out a way to remove these rules.
allow untrusted_app shell_data_file:file { getattr open read ioctl lock };
allow untrusted_app shell_data_file:dir { open getattr read search ioctl };

# b/18504118: Allow reads from /data/anr/traces.txt
# TODO: We shouldn't be allowing all untrusted_apps to read
# this file. This is only needed for the GMS feedback agent.
# See also b/18340553. GMS runs as untrusted_app, and
# it's too late to change the domain it runs in.
# This line needs to be deleted.
allow untrusted_app anr_data_file:file { getattr open read ioctl lock };

#
# Rules migrated from old app domains coalesced into untrusted_app.
# This includes what used to be media_app, shared_app, and release_app.
#

# Access /dev/mtp_usb.
allow untrusted_app mtp_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access to /data/media.
allow untrusted_app media_rw_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow untrusted_app media_rw_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Write to /cache.
allow untrusted_app cache_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow untrusted_app cache_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

###
### neverallow rules
###

# Receive or send uevent messages.
neverallow untrusted_app domain:netlink_kobject_uevent_socket *;

# Receive or send generic netlink messages
neverallow untrusted_app domain:netlink_socket *;

# Too much leaky information in debugfs. It's a security
# best practice to ensure these files aren't readable.
neverallow untrusted_app debugfs:file read;

# Do not allow untrusted apps to register services.
# Only trusted components of Android should be registering
# services.
neverallow untrusted_app service_manager_type:service_manager add;

# Do not allow untrusted_apps to connect to the property service
# or set properties. b/10243159
neverallow untrusted_app property_socket:sock_file write;
neverallow untrusted_app init:unix_stream_socket connectto;
neverallow untrusted_app property_type:property_service set;

# Allow verifier to access staged apks.
allow untrusted_app { apk_tmp_file apk_private_tmp_file }:dir { open getattr read search ioctl };
allow untrusted_app { apk_tmp_file apk_private_tmp_file }:file { getattr open read ioctl lock };
#line 1 "external/sepolicy/mdnsd.te"
# mdns daemon
type mdnsd, domain;
type mdnsd_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init mdnsd_exec:file { getattr open read execute };
#line 5
allow init mdnsd:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow mdnsd mdnsd_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow mdnsd init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init mdnsd:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init mdnsd:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init mdnsd_exec:process mdnsd;
#line 5

#line 5

#line 5
type mdnsd_tmpfs, file_type;
#line 5
type_transition mdnsd tmpfs:file mdnsd_tmpfs;
#line 5
allow mdnsd mdnsd_tmpfs:file { read write };
#line 5

#line 5


#line 6
typeattribute mdnsd netdomain;
#line 6

#line 1 "external/sepolicy/runas.te"
type runas, domain, mlstrustedsubject;
type runas_exec, exec_type, file_type;

# ndk-gdb invokes adb shell run-as.

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow shell runas_exec:file { getattr open read execute };
#line 5
allow shell runas:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow runas runas_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow runas shell:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit shell runas:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow shell runas:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition shell runas_exec:process runas;
#line 5

allow runas adbd:process sigchld;
allow runas shell:fd use;
allow runas shell:fifo_file { read write };
allow runas devpts:chr_file { read write ioctl };
allow runas shell_data_file:file { read write };

# run-as reads package information.
allow runas system_data_file:file { getattr open read ioctl lock };

# run-as checks and changes to the app data dir.
dontaudit runas self:capability dac_override;
allow runas app_data_file:dir { getattr search };

# run-as switches to the app UID/GID.
allow runas self:capability { setuid setgid };

# run-as switches to the app security context.
# read /seapp_contexts and /data/security/seapp_contexts

#line 24
allow runas security_file:dir { open getattr read search ioctl };
#line 24
allow runas security_file:file { getattr open read ioctl lock };
#line 24


#line 25
allow runas selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 25
allow runas kernel:security check_context;
#line 25
 # validate context
allow runas self:process setcurrent;
allow runas { appdomain -system_app }:process dyntransition; # setcon
#line 1 "external/sepolicy/dhcp.te"
type dhcp, domain;
type dhcp_exec, exec_type, file_type;
type dhcp_data_file, file_type, data_file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init dhcp_exec:file { getattr open read execute };
#line 5
allow init dhcp:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow dhcp dhcp_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow dhcp init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init dhcp:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init dhcp:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init dhcp_exec:process dhcp;
#line 5

#line 5

#line 5
type dhcp_tmpfs, file_type;
#line 5
type_transition dhcp tmpfs:file dhcp_tmpfs;
#line 5
allow dhcp dhcp_tmpfs:file { read write };
#line 5

#line 5


#line 6
typeattribute dhcp netdomain;
#line 6


allow dhcp cgroup:dir { create write add_name };
allow dhcp self:capability { setgid setuid net_admin net_raw net_bind_service };
allow dhcp self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow dhcp self:netlink_route_socket nlmsg_write;
allow dhcp shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow dhcp system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# For /proc/sys/net/ipv4/conf/*/promote_secondaries
allow dhcp proc_net:file write;
allow dhcp dhcp_prop:property_service set;
allow dhcp pan_result_prop:property_service set;

#line 18
allow dhcp property_socket:sock_file write;
#line 18
allow dhcp init:unix_stream_socket connectto;
#line 18


type_transition dhcp system_data_file:{ dir file } dhcp_data_file;
allow dhcp dhcp_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow dhcp dhcp_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# PAN connections
allow dhcp netd:fd use;
allow dhcp netd:fifo_file { { getattr open read ioctl lock } { open append write } };
allow dhcp netd:{ { udp_socket unix_dgram_socket } unix_stream_socket } { read write };
allow dhcp netd:{ netlink_kobject_uevent_socket netlink_route_socket netlink_nflog_socket } { read write };
#line 1 "external/sepolicy/unconfined.te"
#######################################################
#
# This is the unconfined template. This template is the base policy
# which is used by daemons and other privileged components of
# Android.
#
# Historically, this template was called "unconfined" because it
# allowed the domain to do anything it wanted. Over time,
# this has changed, and will continue to change in the future.
# The rules in this file will be removed when no remaining
# unconfined domains require it, or when the rules contradict
# Android security best practices. Domains which need rules not
# provided by the unconfined template should add them directly to
# the relevant policy.
#
# The use of this template is discouraged.
######################################################

allow unconfineddomain self:capability ~{ sys_ptrace sys_rawio mknod sys_module audit_write audit_control linux_immutable };
allow unconfineddomain self:capability2 ~{ mac_override mac_admin };
allow unconfineddomain kernel:security ~{ load_policy setenforce setcheckreqprot setbool setsecparam };
allow unconfineddomain kernel:system ~{ syslog_read syslog_mod syslog_console };
allow unconfineddomain domain:fd *;
allow unconfineddomain domain:dir { open getattr read search ioctl };
allow unconfineddomain domain:lnk_file { getattr open read ioctl lock };
allow unconfineddomain domain:{ fifo_file file } { { getattr open read ioctl lock } { open append write } };
allow unconfineddomain domain:{
    socket
    netlink_socket
    key_socket
    unix_stream_socket
    unix_dgram_socket
    netlink_route_socket
    netlink_firewall_socket
    netlink_tcpdiag_socket
    netlink_nflog_socket
    netlink_xfrm_socket
    netlink_selinux_socket
    netlink_audit_socket
    netlink_ip6fw_socket
    netlink_dnrt_socket
    netlink_kobject_uevent_socket
    tun_socket
} *;
allow unconfineddomain domain:{ sem msgq shm ipc } *;
allow unconfineddomain domain:key *;
allow unconfineddomain {fs_type -contextmount_type -sdcard_type}:{ dir lnk_file sock_file fifo_file } ~relabelto;
allow unconfineddomain dev_type:{ dir lnk_file sock_file fifo_file } ~relabelto;
allow unconfineddomain {
    file_type
    -keystore_data_file
    -property_data_file
    -system_file
    -exec_type
    -security_file
    -shell_data_file
    -app_data_file
}:{ dir lnk_file sock_file fifo_file } ~relabelto;
allow unconfineddomain exec_type:dir { open getattr read search ioctl };
allow unconfineddomain exec_type:file { { getattr open read ioctl lock } execute };
allow unconfineddomain exec_type:lnk_file { getattr open read ioctl lock };
allow unconfineddomain system_file:dir { open getattr read search ioctl };
allow unconfineddomain system_file:file { { getattr open read ioctl lock } execute };
allow unconfineddomain system_file:lnk_file { getattr open read ioctl lock };
allow unconfineddomain {
    fs_type
    -usermodehelper
    -proc_security
    -contextmount_type
    -rootfs
    -sdcard_type
}:{ chr_file file } ~{entrypoint execute_no_trans execmod execute relabelto};
allow unconfineddomain {dev_type -kmem_device}:{ chr_file file } ~{entrypoint execute_no_trans execmod execute relabelto};
allow unconfineddomain {
    file_type
    -keystore_data_file
    -property_data_file
    -system_file
    -exec_type
    -security_file
    -shell_data_file
    -app_data_file
}:{ chr_file file } ~{entrypoint execute_no_trans execmod execute relabelto};
allow unconfineddomain rootfs:file execute;
allow unconfineddomain contextmount_type:dir { open getattr read search ioctl };
allow unconfineddomain contextmount_type:{ file lnk_file sock_file fifo_file } { getattr open read ioctl lock };
allow unconfineddomain node_type:node *;
allow unconfineddomain netif_type:netif *;
allow unconfineddomain domain:peer recv;
allow unconfineddomain { domain -init }:binder { call transfer set_context_mgr };
#line 1 "external/sepolicy/tee.te"
##
# trusted execution environment (tee) daemon
#
type tee, domain;
type tee_exec, exec_type, file_type;
type tee_device, dev_type;
type tee_data_file, file_type, data_file_type;


#line 9

#line 9
# Allow the necessary permissions.
#line 9

#line 9
# Old domain may exec the file and transition to the new domain.
#line 9
allow init tee_exec:file { getattr open read execute };
#line 9
allow init tee:process transition;
#line 9
# New domain is entered by executing the file.
#line 9
allow tee tee_exec:file { entrypoint open read execute getattr };
#line 9
# New domain can send SIGCHLD to its caller.
#line 9
allow tee init:process sigchld;
#line 9
# Enable AT_SECURE, i.e. libc secure mode.
#line 9
dontaudit init tee:process noatsecure;
#line 9
# XXX dontaudit candidate but requires further study.
#line 9
allow init tee:process { siginh rlimitinh };
#line 9

#line 9
# Make the transition occur by default.
#line 9
type_transition init tee_exec:process tee;
#line 9

#line 9

#line 9
type tee_tmpfs, file_type;
#line 9
type_transition tee tmpfs:file tee_tmpfs;
#line 9
allow tee tee_tmpfs:file { read write };
#line 9

#line 9

allow tee self:capability { dac_override };
allow tee tee_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow tee tee_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow tee tee_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow tee self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
#line 1 "external/sepolicy/vold.te"
# volume manager
type vold, domain;
type vold_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init vold_exec:file { getattr open read execute };
#line 5
allow init vold:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow vold vold_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow vold init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init vold:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init vold:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init vold_exec:process vold;
#line 5

#line 5

#line 5
type vold_tmpfs, file_type;
#line 5
type_transition vold tmpfs:file vold_tmpfs;
#line 5
allow vold vold_tmpfs:file { read write };
#line 5

#line 5


typeattribute vold mlstrustedsubject;
allow vold system_file:file { getattr execute execute_no_trans };
allow vold block_device:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow vold block_device:blk_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow vold device:dir write;
allow vold devpts:chr_file { { getattr open read ioctl lock } { open append write } };
allow vold rootfs:dir mounton;
allow vold sdcard_type:dir mounton;
allow vold sdcard_type:filesystem { mount remount unmount };
allow vold sdcard_posix:filesystem { relabelto relabelfrom };
#line 18

allow vold labeledfs:filesystem { relabelfrom };
allow vold sdcard_type:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow vold sdcard_type:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow vold tmpfs:filesystem { mount unmount };
allow vold tmpfs:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow vold tmpfs:dir mounton;
allow vold self:capability { net_admin dac_override mknod sys_admin chown fowner fsetid };
allow vold self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow vold app_data_file:dir search;
allow vold app_data_file:file { { getattr open read ioctl lock } { open append write } };
allow vold loop_device:blk_file { { getattr open read ioctl lock } { open append write } };
allow vold dm_device:chr_file { { getattr open read ioctl lock } { open append write } };
# For vold Process::killProcessesWithOpenFiles function.
allow vold domain:dir { open getattr read search ioctl };
allow vold domain:{ file lnk_file } { getattr open read ioctl lock };
allow vold domain:process { signal sigkill };
allow vold self:capability { sys_ptrace kill };

# For blkid
allow vold shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# XXX Label sysfs files with a specific type?
allow vold sysfs:file { { getattr open read ioctl lock } { open append write } };


#line 43
type_transition vold device:chr_file klog_device "__kmsg__";
#line 43
allow vold klog_device:chr_file { create open write unlink };
#line 43
allow vold device:dir { write add_name remove_name };
#line 43


# Log fsck results
allow vold fscklogs:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow vold fscklogs:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

#
# Rules to support encrypted fs support.
#

# Set property.

#line 54
allow vold property_socket:sock_file write;
#line 54
allow vold init:unix_stream_socket connectto;
#line 54


# Unmount and mount the fs.
allow vold labeledfs:filesystem { mount unmount remount };

# Access /efs/userdata_footer.
# XXX Split into a separate type?
allow vold efs_file:file { { getattr open read ioctl lock } { open append write } };

# Create and mount on /data/tmp_mnt.
allow vold system_data_file:dir { create { { open getattr read search ioctl } { open search write add_name remove_name } } mounton };

# Set scheduling policy of kernel processes
allow vold kernel:process setsched;

# Property Service
allow vold vold_prop:property_service set;
allow vold powerctl_prop:property_service set;
allow vold ctl_fuse_prop:property_service set;

# ASEC
allow vold asec_image_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow vold asec_image_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };

#line 77
allow vold security_file:dir { open getattr read search ioctl };
#line 77
allow vold security_file:file { getattr open read ioctl lock };
#line 77

allow vold asec_apk_file:dir { { { open getattr read search ioctl } { open search write add_name remove_name } } setattr relabelfrom relabelto };
allow vold asec_public_file:dir { relabelto setattr };
allow vold asec_apk_file:file { { getattr open read ioctl lock } setattr relabelfrom relabelto };
allow vold asec_public_file:file { relabelto setattr };
# restorecon files in asec containers created on 4.2 or earlier.
allow vold unlabeled:dir { { open getattr read search ioctl } setattr relabelfrom };
allow vold unlabeled:file { { getattr open read ioctl lock } setattr relabelfrom };

# Handle wake locks (used for device encryption)

#line 87
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 87
allow vold sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
#line 87
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 87
allow vold self:capability2 block_suspend;
#line 87


# talk to batteryservice

#line 90
# Call the servicemanager and transfer references to it.
#line 90
allow vold servicemanager:binder { call transfer };
#line 90
# servicemanager performs getpidcon on clients.
#line 90
allow servicemanager vold:dir search;
#line 90
allow servicemanager vold:file { read open };
#line 90
allow servicemanager vold:process getattr;
#line 90
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 90
# all domains in domain.te.
#line 90


#line 91
# Call the server domain and optionally transfer references to it.
#line 91
allow vold healthd:binder { call transfer };
#line 91
# Allow the serverdomain to transfer references to the client on the reply.
#line 91
allow healthd vold:binder transfer;
#line 91
# Receive and use open files from the server.
#line 91
allow vold healthd:fd use;
#line 91


# talk to keymaster
allow vold tee_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access userdata block device.
allow vold userdata_block_device:blk_file { { getattr open read ioctl lock } { open append write } };
auditallow vold userdata_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# For UMS tuning
allow vold proc_dirty_ratio:file { { getattr open read ioctl lock } { open append write } };

#line 1 "external/sepolicy/vdc.te"
# vdc spawned from init for the following services:
#  defaultcrypto
#  encrypt
#
# We also transition into this domain from dumpstate, when
# collecting bug reports.

type vdc, domain;
type vdc_exec, exec_type, file_type;


#line 11

#line 11
# Allow the necessary permissions.
#line 11

#line 11
# Old domain may exec the file and transition to the new domain.
#line 11
allow init vdc_exec:file { getattr open read execute };
#line 11
allow init vdc:process transition;
#line 11
# New domain is entered by executing the file.
#line 11
allow vdc vdc_exec:file { entrypoint open read execute getattr };
#line 11
# New domain can send SIGCHLD to its caller.
#line 11
allow vdc init:process sigchld;
#line 11
# Enable AT_SECURE, i.e. libc secure mode.
#line 11
dontaudit init vdc:process noatsecure;
#line 11
# XXX dontaudit candidate but requires further study.
#line 11
allow init vdc:process { siginh rlimitinh };
#line 11

#line 11
# Make the transition occur by default.
#line 11
type_transition init vdc_exec:process vdc;
#line 11

#line 11

#line 11
type vdc_tmpfs, file_type;
#line 11
type_transition vdc tmpfs:file vdc_tmpfs;
#line 11
allow vdc vdc_tmpfs:file { read write };
#line 11

#line 11



#line 13
allow vdc vold_socket:sock_file write;
#line 13
allow vdc vold:unix_stream_socket connectto;
#line 13


# vdc sends information back to dumpstate when "adb bugreport" is used
allow vdc dumpstate:fd use;
allow vdc dumpstate:unix_stream_socket { read write getattr };

# vdc information is written to shell owned bugreport files
allow vdc shell_data_file:file { write getattr };

# Why?
allow vdc dumpstate:unix_dgram_socket { read write };
#line 1 "external/sepolicy/service.te"
type bluetooth_service,         service_manager_type;
type default_android_service,   service_manager_type;
type drmserver_service,         service_manager_type;
type healthd_service,           service_manager_type;
type inputflinger_service,      service_manager_type;
type keystore_service,          service_manager_type;
type mediaserver_service,       service_manager_type;
type nfc_service,               service_manager_type;
type processinfo_service,       service_manager_type;
type radio_service,             service_manager_type;
type surfaceflinger_service,    service_manager_type;
type system_app_service,        service_manager_type;
type system_server_service,     service_manager_type;
#line 1 "external/sepolicy/shared_relro.te"
# Process which creates/updates shared RELRO files to be used by other apps.
type shared_relro, domain;

# The shared relro process is a Java program forked from the zygote, so it
# inherits from app to get basic permissions it needs to run.

#line 6
typeattribute shared_relro appdomain;
#line 6
# Label ashmem objects with our own unique type.
#line 6

#line 6
type shared_relro_tmpfs, file_type;
#line 6
type_transition shared_relro tmpfs:file shared_relro_tmpfs;
#line 6
allow shared_relro shared_relro_tmpfs:file { read write };
#line 6

#line 6
# Map with PROT_EXEC.
#line 6
allow shared_relro shared_relro_tmpfs:file execute;
#line 6


# Grant write access to the shared relro files/directory.
allow shared_relro shared_relro_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow shared_relro shared_relro_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
#line 1 "external/sepolicy/nfc.te"
# nfc subsystem
type nfc, domain;

#line 3
typeattribute nfc appdomain;
#line 3
# Label ashmem objects with our own unique type.
#line 3

#line 3
type nfc_tmpfs, file_type;
#line 3
type_transition nfc tmpfs:file nfc_tmpfs;
#line 3
allow nfc nfc_tmpfs:file { read write };
#line 3

#line 3
# Map with PROT_EXEC.
#line 3
allow nfc nfc_tmpfs:file execute;
#line 3


#line 4
typeattribute nfc netdomain;
#line 4


#line 5
typeattribute nfc binderservicedomain;
#line 5


# Set NFC properties

#line 8
allow nfc property_socket:sock_file write;
#line 8
allow nfc init:unix_stream_socket connectto;
#line 8

allow nfc nfc_prop:property_service set;

# NFC device access.
allow nfc nfc_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Data file accesses.
allow nfc nfc_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow nfc nfc_data_file:{ file lnk_file sock_file fifo_file } { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

allow nfc sysfs_nfc_power_writable:file { { getattr open read ioctl lock } { open append write } };
allow nfc sysfs:file write;

allow nfc nfc_service:service_manager add;
#line 1 "external/sepolicy/ueventd.te"
# ueventd seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type ueventd, domain;

#line 4
type ueventd_tmpfs, file_type;
#line 4
type_transition ueventd tmpfs:file ueventd_tmpfs;
#line 4
allow ueventd ueventd_tmpfs:file { read write };
#line 4


#line 5
type_transition ueventd device:chr_file klog_device "__kmsg__";
#line 5
allow ueventd klog_device:chr_file { create open write unlink };
#line 5
allow ueventd device:dir { write add_name remove_name };
#line 5


#line 6
allow ueventd security_file:dir { open getattr read search ioctl };
#line 6
allow ueventd security_file:file { getattr open read ioctl lock };
#line 6

allow ueventd init:process sigchld;
allow ueventd self:capability { chown mknod net_admin setgid fsetid sys_rawio dac_override fowner };
allow ueventd device:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow ueventd device:chr_file { { getattr open read ioctl lock } { open append write } };
allow ueventd sysfs:file { { getattr open read ioctl lock } { open append write } };
allow ueventd sysfs_type:{ file lnk_file } { relabelfrom relabelto setattr getattr };
allow ueventd sysfs_type:dir { relabelfrom relabelto setattr { open getattr read search ioctl } };
allow ueventd sysfs_devices_system_cpu:file { { getattr open read ioctl lock } { open append write } };
allow ueventd tmpfs:chr_file { { getattr open read ioctl lock } { open append write } };
allow ueventd dev_type:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow ueventd dev_type:lnk_file { create unlink };
allow ueventd dev_type:chr_file { create setattr unlink };
allow ueventd dev_type:blk_file { create setattr unlink };
allow ueventd self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow ueventd efs_file:dir search;
allow ueventd efs_file:file { getattr open read ioctl lock };

# Use setfscreatecon() to label /dev directories and files.
allow ueventd self:process setfscreate;
#line 1 "external/sepolicy/gpsd.te"
# gpsd - GPS daemon
type gpsd, domain;
type gpsd_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init gpsd_exec:file { getattr open read execute };
#line 5
allow init gpsd:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow gpsd gpsd_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow gpsd init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init gpsd:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init gpsd:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init gpsd_exec:process gpsd;
#line 5

#line 5

#line 5
type gpsd_tmpfs, file_type;
#line 5
type_transition gpsd tmpfs:file gpsd_tmpfs;
#line 5
allow gpsd gpsd_tmpfs:file { read write };
#line 5

#line 5


#line 6
typeattribute gpsd netdomain;
#line 6

allow gpsd gps_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow gpsd gps_data_file:{ file lnk_file sock_file fifo_file } { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
# Socket is created by the daemon, not by init, and under /data/gps,
# not under /dev/socket.
type_transition gpsd gps_data_file:sock_file gps_socket;
allow gpsd gps_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
# XXX Label sysfs files with a specific type?
allow gpsd sysfs:file { { getattr open read ioctl lock } { open append write } };

allow gpsd gps_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Execute the shell or system commands.
allow gpsd shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow gpsd system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
#line 1 "external/sepolicy/dumpstate.te"
# dumpstate
type dumpstate, domain;
type dumpstate_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init dumpstate_exec:file { getattr open read execute };
#line 5
allow init dumpstate:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow dumpstate dumpstate_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow dumpstate init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init dumpstate:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init dumpstate:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init dumpstate_exec:process dumpstate;
#line 5

#line 5

#line 5
type dumpstate_tmpfs, file_type;
#line 5
type_transition dumpstate tmpfs:file dumpstate_tmpfs;
#line 5
allow dumpstate dumpstate_tmpfs:file { read write };
#line 5

#line 5


#line 6
typeattribute dumpstate netdomain;
#line 6


#line 7
# Call the servicemanager and transfer references to it.
#line 7
allow dumpstate servicemanager:binder { call transfer };
#line 7
# servicemanager performs getpidcon on clients.
#line 7
allow servicemanager dumpstate:dir search;
#line 7
allow servicemanager dumpstate:file { read open };
#line 7
allow servicemanager dumpstate:process getattr;
#line 7
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 7
# all domains in domain.te.
#line 7


# Drop privileges by switching UID / GID
allow dumpstate self:capability { setuid setgid };

# Allow dumpstate to scan through /proc/pid for all processes

#line 13
allow dumpstate domain:dir { open getattr read search ioctl };
#line 13
allow dumpstate domain:{ file lnk_file } { getattr open read ioctl lock };
#line 13


# Send signals to processes
allow dumpstate self:capability kill;

# Allow executing files on system, such as:
#   /system/bin/toolbox
#   /system/bin/logcat
#   /system/bin/dumpsys
allow dumpstate system_file:file execute_no_trans;

# Create and write into /data/anr/
allow dumpstate self:capability { dac_override chown fowner fsetid };
allow dumpstate anr_data_file:dir { { { open getattr read search ioctl } { open search write add_name remove_name } } relabelto };
allow dumpstate anr_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow dumpstate system_data_file:dir { { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } } relabelfrom };

# Allow reading /data/system/uiderrors.txt
# TODO: scope this down.
allow dumpstate system_data_file:file { getattr open read ioctl lock };

# Read dmesg
allow dumpstate self:capability2 syslog;
allow dumpstate kernel:system syslog_read;

# Read /sys/fs/pstore/console-ramoops
allow dumpstate pstorefs:dir { open getattr read search ioctl };
allow dumpstate pstorefs:file { getattr open read ioctl lock };

# Get process attributes
allow dumpstate domain:process getattr;

# Signal java processes to dump their stack
allow dumpstate { appdomain system_server }:process signal;

# Signal native processes to dump their stack.
# This list comes from native_processes_to_dump in dumpstate/utils.c
allow dumpstate { drmserver mediaserver sdcardd surfaceflinger }:process signal;

# Execute and transition to the vdc domain

#line 53
# Allow the necessary permissions.
#line 53

#line 53
# Old domain may exec the file and transition to the new domain.
#line 53
allow dumpstate vdc_exec:file { getattr open read execute };
#line 53
allow dumpstate vdc:process transition;
#line 53
# New domain is entered by executing the file.
#line 53
allow vdc vdc_exec:file { entrypoint open read execute getattr };
#line 53
# New domain can send SIGCHLD to its caller.
#line 53
allow vdc dumpstate:process sigchld;
#line 53
# Enable AT_SECURE, i.e. libc secure mode.
#line 53
dontaudit dumpstate vdc:process noatsecure;
#line 53
# XXX dontaudit candidate but requires further study.
#line 53
allow dumpstate vdc:process { siginh rlimitinh };
#line 53

#line 53
# Make the transition occur by default.
#line 53
type_transition dumpstate vdc_exec:process vdc;
#line 53


# Vibrate the device after we're done collecting the bugreport
# /sys/class/timed_output/vibrator/enable
# TODO: create a new file class, instead of allowing write access to all of /sys
allow dumpstate sysfs:file { open append write };

# Other random bits of data we want to collect
allow dumpstate qtaguid_proc:file { getattr open read ioctl lock };
allow dumpstate debugfs:file { getattr open read ioctl lock };

# Allow dumpstate to make binder calls to any binder service

#line 65
# Call the server domain and optionally transfer references to it.
#line 65
allow dumpstate binderservicedomain:binder { call transfer };
#line 65
# Allow the serverdomain to transfer references to the client on the reply.
#line 65
allow binderservicedomain dumpstate:binder transfer;
#line 65
# Receive and use open files from the server.
#line 65
allow dumpstate binderservicedomain:fd use;
#line 65


#line 66
# Call the server domain and optionally transfer references to it.
#line 66
allow dumpstate appdomain:binder { call transfer };
#line 66
# Allow the serverdomain to transfer references to the client on the reply.
#line 66
allow appdomain dumpstate:binder transfer;
#line 66
# Receive and use open files from the server.
#line 66
allow dumpstate appdomain:fd use;
#line 66


# Reading /proc/PID/maps of other processes
allow dumpstate self:capability sys_ptrace;

# Allow the bugreport service to create a file in
# /data/data/com.android.shell/files/bugreports/bugreport
allow dumpstate shell_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow dumpstate shell_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Run a shell.
allow dumpstate shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# For running am and similar framework commands.
# Run /system/bin/app_process.
allow dumpstate zygote_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# Dalvik Compiler JIT.
allow dumpstate ashmem_device:chr_file execute;
allow dumpstate dumpstate_tmpfs:file execute;
allow dumpstate self:process execmem;
# For art.
allow dumpstate dalvikcache_data_file:file execute;

# Dumpstate calls screencap, which grabs a screenshot. Needs gpu access
allow dumpstate gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };

# logd access

#line 93

#line 93
allow dumpstate logdr_socket:sock_file write;
#line 93
allow dumpstate logd:unix_stream_socket connectto;
#line 93

#line 93


#line 94
# Group AID_LOG checked by filesystem & logd
#line 94
# to permit control commands
#line 94

#line 94
allow dumpstate logd_socket:sock_file write;
#line 94
allow dumpstate logd:unix_stream_socket connectto;
#line 94

#line 94


# Read network state info files.
allow dumpstate net_data_file:dir search;
allow dumpstate net_data_file:file { getattr open read ioctl lock };

# Access /data/tombstones.
allow dumpstate tombstone_data_file:dir { open getattr read search ioctl };
allow dumpstate tombstone_data_file:file { getattr open read ioctl lock };

# Access /system/bin executables to determine type of executable.
allow dumpstate {drmserver_exec mediaserver_exec sdcardd_exec surfaceflinger_exec}:file { getattr open read ioctl lock };
#line 1 "external/sepolicy/wpa.te"
# wpa - wpa supplicant or equivalent
type wpa, domain;
type wpa_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init wpa_exec:file { getattr open read execute };
#line 5
allow init wpa:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow wpa wpa_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow wpa init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init wpa:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init wpa:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init wpa_exec:process wpa;
#line 5

#line 5

#line 5
type wpa_tmpfs, file_type;
#line 5
type_transition wpa tmpfs:file wpa_tmpfs;
#line 5
allow wpa wpa_tmpfs:file { read write };
#line 5

#line 5



#line 7
typeattribute wpa netdomain;
#line 7


allow wpa kernel:system module_request;
allow wpa self:capability { setuid net_admin setgid net_raw };
allow wpa cgroup:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow wpa self:netlink_route_socket nlmsg_write;
allow wpa self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow wpa self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow wpa wifi_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow wpa wifi_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

#line 17
allow wpa system_wpa_socket:sock_file write;
#line 17
allow wpa system_server:unix_dgram_socket sendto;
#line 17



#line 19
# Call the servicemanager and transfer references to it.
#line 19
allow wpa servicemanager:binder { call transfer };
#line 19
# servicemanager performs getpidcon on clients.
#line 19
allow servicemanager wpa:dir search;
#line 19
allow servicemanager wpa:file { read open };
#line 19
allow servicemanager wpa:process getattr;
#line 19
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 19
# all domains in domain.te.
#line 19


# Create a socket for receiving info from wpa
type_transition wpa wifi_data_file:dir wpa_socket "sockets";
allow wpa wpa_socket:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow wpa wpa_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };


#line 26
  allow keystore wpa:dir search;
#line 26
  allow keystore wpa:file { read open };
#line 26
  allow keystore wpa:process getattr;
#line 26
  
#line 26
# Call the server domain and optionally transfer references to it.
#line 26
allow wpa keystore:binder { call transfer };
#line 26
# Allow the serverdomain to transfer references to the client on the reply.
#line 26
allow keystore wpa:binder transfer;
#line 26
# Receive and use open files from the server.
#line 26
allow wpa keystore:fd use;
#line 26

#line 26


# WPA (wifi) has a restricted set of permissions from the default.
allow wpa keystore:keystore_key {
	get
	sign
	verify
};

# Allow wpa_cli to work. wpa_cli creates a socket in
# /data/misc/wifi/sockets which wpa supplicant communicates with.

#line 37
  
#line 37
allow wpa wpa_socket:sock_file write;
#line 37
allow wpa su:unix_dgram_socket sendto;
#line 37

#line 39

#line 1 "external/sepolicy/init.te"
# init switches to init domain (via init.rc).
type init, domain;
# init is unconfined.

#line 4
typeattribute init mlstrustedsubject;
#line 4
typeattribute init unconfineddomain;
#line 4


#line 5
type init_tmpfs, file_type;
#line 5
type_transition init tmpfs:file init_tmpfs;
#line 5
allow init init_tmpfs:file { read write };
#line 5


allow init self:capability { sys_rawio mknod };

# Run helpers from / or /system without changing domain.
# We do not include exec_type here since generally those
# should always involve a domain transition.
allow init rootfs:file execute_no_trans;
allow init system_file:file execute_no_trans;

# Running e2fsck or mkswap via fs_mgr.
allow init dev_type:blk_file { { getattr open read ioctl lock } { open append write } };

# Mounting filesystems.
# Only allow relabelto for types used in context= mount options,
# which should all be assigned the contextmount_type attribute.
# This can be done in device-specific policy via type or typeattribute
# declarations.
allow init fs_type:filesystem ~relabelto;
allow init unlabeled:filesystem ~relabelto;
allow init contextmount_type:filesystem relabelto;

# Allow read-only access to context= mounted filesystems.
allow init contextmount_type:dir { open getattr read search ioctl };
allow init contextmount_type:{ file lnk_file sock_file fifo_file } { getattr open read ioctl lock };

# restorecon /adb_keys or any other rootfs files to a more specific type.
allow init rootfs:file relabelfrom;

# restorecon and restorecon_recursive calls from init.rc files.
# system/core/init.rc requires at least cache_file and data_file_type.
# init.<board>.rc files often include device-specific types, so
# we just allow all file types except /system files here.
allow init {file_type -system_file -exec_type}:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } relabelto;
allow init sysfs_type:{ dir file lnk_file } relabelto;

# Unlabeled file access for upgrades from 4.2.
allow init unlabeled:dir { { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } } relabelfrom };
allow init unlabeled:{ file lnk_file sock_file fifo_file } { { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } } relabelfrom };

# Create /data/security from init.rc post-fs-data.
allow init security_file:dir { create setattr };

# setprop selinux.reload_policy 1 from init.rc post-fs-data.
allow init security_prop:property_service set;

# Reload policy upon setprop selinux.reload_policy 1.

#line 52
allow init security_file:dir { open getattr read search ioctl };
#line 52
allow init security_file:{ file lnk_file } { getattr open read ioctl lock };
#line 52

allow init kernel:security load_policy;

# Any operation that can modify the kernel ring buffer, e.g. clear
# or a read that consumes the messages that were read.
allow init kernel:system syslog_mod;

# Set usermodehelpers and /proc security settings.
allow init usermodehelper:file { { getattr open read ioctl lock } { open append write } };
allow init proc_security:file { { getattr open read ioctl lock } { open append write } };

# Transitions to seclabel processes in init.rc

#line 64
# Old domain may exec the file and transition to the new domain.
#line 64
allow init rootfs:file { getattr open read execute };
#line 64
allow init adbd:process transition;
#line 64
# New domain is entered by executing the file.
#line 64
allow adbd rootfs:file { entrypoint open read execute getattr };
#line 64
# New domain can send SIGCHLD to its caller.
#line 64
allow adbd init:process sigchld;
#line 64
# Enable AT_SECURE, i.e. libc secure mode.
#line 64
dontaudit init adbd:process noatsecure;
#line 64
# XXX dontaudit candidate but requires further study.
#line 64
allow init adbd:process { siginh rlimitinh };
#line 64


#line 65
# Old domain may exec the file and transition to the new domain.
#line 65
allow init rootfs:file { getattr open read execute };
#line 65
allow init healthd:process transition;
#line 65
# New domain is entered by executing the file.
#line 65
allow healthd rootfs:file { entrypoint open read execute getattr };
#line 65
# New domain can send SIGCHLD to its caller.
#line 65
allow healthd init:process sigchld;
#line 65
# Enable AT_SECURE, i.e. libc secure mode.
#line 65
dontaudit init healthd:process noatsecure;
#line 65
# XXX dontaudit candidate but requires further study.
#line 65
allow init healthd:process { siginh rlimitinh };
#line 65

#line 68


#line 69
# Old domain may exec the file and transition to the new domain.
#line 69
allow init shell_exec:file { getattr open read execute };
#line 69
allow init shell:process transition;
#line 69
# New domain is entered by executing the file.
#line 69
allow shell shell_exec:file { entrypoint open read execute getattr };
#line 69
# New domain can send SIGCHLD to its caller.
#line 69
allow shell init:process sigchld;
#line 69
# Enable AT_SECURE, i.e. libc secure mode.
#line 69
dontaudit init shell:process noatsecure;
#line 69
# XXX dontaudit candidate but requires further study.
#line 69
allow init shell:process { siginh rlimitinh };
#line 69


#line 70
# Old domain may exec the file and transition to the new domain.
#line 70
allow init rootfs:file { getattr open read execute };
#line 70
allow init ueventd:process transition;
#line 70
# New domain is entered by executing the file.
#line 70
allow ueventd rootfs:file { entrypoint open read execute getattr };
#line 70
# New domain can send SIGCHLD to its caller.
#line 70
allow ueventd init:process sigchld;
#line 70
# Enable AT_SECURE, i.e. libc secure mode.
#line 70
dontaudit init ueventd:process noatsecure;
#line 70
# XXX dontaudit candidate but requires further study.
#line 70
allow init ueventd:process { siginh rlimitinh };
#line 70


#line 71
# Old domain may exec the file and transition to the new domain.
#line 71
allow init rootfs:file { getattr open read execute };
#line 71
allow init watchdogd:process transition;
#line 71
# New domain is entered by executing the file.
#line 71
allow watchdogd rootfs:file { entrypoint open read execute getattr };
#line 71
# New domain can send SIGCHLD to its caller.
#line 71
allow watchdogd init:process sigchld;
#line 71
# Enable AT_SECURE, i.e. libc secure mode.
#line 71
dontaudit init watchdogd:process noatsecure;
#line 71
# XXX dontaudit candidate but requires further study.
#line 71
allow init watchdogd:process { siginh rlimitinh };
#line 71


# Certain domains need LD_PRELOAD passed from init.
# https://android-review.googlesource.com/94851
# For now, allow it to most domains.
# TODO: scope this down.
allow init { domain -lmkd }:process noatsecure;

# Support "adb shell stop"
allow init domain:process sigkill;

# Init creates keystore's directory on boot, and walks through
# the directory as part of a recursive restorecon.
allow init keystore_data_file:dir { open create read getattr setattr search };
allow init keystore_data_file:file { getattr };

# Init creates /data/local/tmp at boot
allow init shell_data_file:dir { open create read getattr setattr search };
allow init shell_data_file:file { getattr };

# Use setexeccon(), setfscreatecon(), and setsockcreatecon().
# setexec is for services with seclabel options.
# setfscreate is for labeling directories and socket files.
# setsockcreate is for labeling local/unix domain sockets.
allow init self:process { setexec setfscreate setsockcreate };

# Create /data/property and files within it.
allow init property_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow init property_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Set any property.
allow init property_type:property_service set;

# Run "ifup lo" to bring up the localhost interface
allow init self:udp_socket { create ioctl };

# This line seems suspect, as it should not really need to
# set scheduling parameters for a kernel domain task.
allow init kernel:process setsched;

# Allow init to read the context on userdirs (but not their contents)
# We need this before relabeling them coming from 4.4
allow init app_data_file:{ lnk_file dir } { getattr relabelfrom };

###
### neverallow rules
###

# The init domain is only entered via setcon from the kernel domain,
# never via an exec-based transition.
neverallow { domain -kernel} init:process dyntransition;
neverallow domain init:process transition;
neverallow init { file_type fs_type }:file entrypoint;
#line 1 "external/sepolicy/isolated_app.te"
###
### Services with isolatedProcess=true in their manifest.
###
### This file defines the rules for isolated apps. An "isolated
### app" is an APP with UID between AID_ISOLATED_START (99000)
### and AID_ISOLATED_END (99999).
###
### isolated_app includes all the appdomain rules, plus the
### additional following rules:
###

type isolated_app, domain;

#line 13
typeattribute isolated_app appdomain;
#line 13
# Label ashmem objects with our own unique type.
#line 13

#line 13
type isolated_app_tmpfs, file_type;
#line 13
type_transition isolated_app tmpfs:file isolated_app_tmpfs;
#line 13
allow isolated_app isolated_app_tmpfs:file { read write };
#line 13

#line 13
# Map with PROT_EXEC.
#line 13
allow isolated_app isolated_app_tmpfs:file execute;
#line 13


#line 14
typeattribute isolated_app netdomain;
#line 14


# read and write access to app_data_file is already
# granted via app.te. Allow execute.
# Needed to allow dlopen() from Chrome renderer processes.
# See b/15902433 for details.
allow isolated_app app_data_file:file execute;
#line 1 "external/sepolicy/healthd.te"
# healthd seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type healthd, domain;


#line 5
type_transition healthd device:chr_file klog_device "__kmsg__";
#line 5
allow healthd klog_device:chr_file { create open write unlink };
#line 5
allow healthd device:dir { write add_name remove_name };
#line 5

# /dev/__null__ created by init prior to policy load,
# open fd inherited by healthd.
allow healthd tmpfs:chr_file { read write };

allow healthd self:capability { net_admin mknod sys_tty_config };

#line 11
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 11
allow healthd sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
#line 11
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 11
allow healthd self:capability2 block_suspend;
#line 11

allow healthd self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

#line 13
# Call the servicemanager and transfer references to it.
#line 13
allow healthd servicemanager:binder { call transfer };
#line 13
# servicemanager performs getpidcon on clients.
#line 13
allow servicemanager healthd:dir search;
#line 13
allow servicemanager healthd:file { read open };
#line 13
allow servicemanager healthd:process getattr;
#line 13
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 13
# all domains in domain.te.
#line 13


#line 14
typeattribute healthd binderservicedomain;
#line 14


#line 15
# Call the server domain and optionally transfer references to it.
#line 15
allow healthd system_server:binder { call transfer };
#line 15
# Allow the serverdomain to transfer references to the client on the reply.
#line 15
allow system_server healthd:binder transfer;
#line 15
# Receive and use open files from the server.
#line 15
allow healthd system_server:fd use;
#line 15


# Write to state file.
# TODO:  Split into a separate type?
allow healthd sysfs:file write;

###
### healthd: charger mode
###

# Read /sys/fs/pstore/console-ramoops
# Don't worry about overly broad permissions for now, as there's
# only one file in /sys/fs/pstore
allow healthd pstorefs:dir { open getattr read search ioctl };
allow healthd pstorefs:file { getattr open read ioctl lock };

allow healthd graphics_device:dir { open getattr read search ioctl };
allow healthd graphics_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow healthd input_device:dir { open getattr read search ioctl };
allow healthd input_device:chr_file { getattr open read ioctl lock };
allow healthd tty_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow healthd ashmem_device:chr_file execute;
allow healthd self:process execmem;
allow healthd proc_sysrq:file { { getattr open read ioctl lock } { open append write } };
allow healthd self:capability sys_boot;

allow healthd healthd_service:service_manager add;

# Healthd needs to tell init to continue the boot
# process when running in charger mode.

#line 45
allow healthd property_socket:sock_file write;
#line 45
allow healthd init:unix_stream_socket connectto;
#line 45

allow healthd system_prop:property_service set;
#line 1 "external/sepolicy/init_shell.te"
# Restricted domain for shell processes spawned by init.
# Normally these are shell commands or scripts invoked via sh
# from an init*.rc file.  No service should ever run in this domain.
type init_shell, domain;

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init shell_exec:file { getattr open read execute };
#line 5
allow init init_shell:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow init_shell shell_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow init_shell init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init init_shell:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init init_shell:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init shell_exec:process init_shell;
#line 5


#line 6
typeattribute init_shell mlstrustedsubject;
#line 6
typeattribute init_shell unconfineddomain;
#line 6


# Run helpers from / or /system without changing domain.
allow init_shell rootfs:file execute_no_trans;
allow init_shell system_file:file execute_no_trans;
#line 1 "external/sepolicy/system_app.te"
#
# Apps that run with the system UID, e.g. com.android.system.ui,
# com.android.settings.  These are not as privileged as the system
# server.
#
type system_app, domain;

#line 7
typeattribute system_app appdomain;
#line 7
# Label ashmem objects with our own unique type.
#line 7

#line 7
type system_app_tmpfs, file_type;
#line 7
type_transition system_app tmpfs:file system_app_tmpfs;
#line 7
allow system_app system_app_tmpfs:file { read write };
#line 7

#line 7
# Map with PROT_EXEC.
#line 7
allow system_app system_app_tmpfs:file execute;
#line 7


#line 8
typeattribute system_app netdomain;
#line 8


#line 9
typeattribute system_app binderservicedomain;
#line 9


# Read and write /data/data subdirectory.
allow system_app system_app_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_app system_app_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Read /data/misc/keychain subdirectory.
allow system_app keychain_data_file:dir { open getattr read search ioctl };
allow system_app keychain_data_file:file { getattr open read ioctl lock };

# Read and write to other system-owned /data directories, such as
# /data/system/cache and /data/misc/user.
allow system_app system_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_app system_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow system_app misc_user_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_app misc_user_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
# Audit writes to these directories and files so we can identify
# and possibly move these directories into their own type in the future.
auditallow system_app system_data_file:dir { create setattr add_name remove_name rmdir rename };
auditallow system_app system_data_file:file { create setattr append write link unlink rename };

# Read wallpaper file.
allow system_app wallpaper_file:file { getattr open read ioctl lock };

# Write to properties

#line 34
allow system_app property_socket:sock_file write;
#line 34
allow system_app init:unix_stream_socket connectto;
#line 34

allow system_app debug_prop:property_service set;
allow system_app net_radio_prop:property_service set;
allow system_app system_radio_prop:property_service set;
auditallow system_app net_radio_prop:property_service set;
auditallow system_app system_radio_prop:property_service set;
allow system_app system_prop:property_service set;
allow system_app ctl_bugreport_prop:property_service set;
allow system_app logd_prop:property_service set;

# Create /data/anr/traces.txt.
allow system_app anr_data_file:dir { { open getattr read search ioctl } add_name write };
allow system_app anr_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Settings need to access app name and icon from asec
allow system_app asec_apk_file:file { getattr open read ioctl lock };

allow system_app system_app_service:service_manager add;

allow system_app keystore:keystore_key {
	test
	get
	insert
	delete
	exist
	saw
	reset
	password
	lock
	unlock
	zero
	sign
	verify
	grant
	duplicate
	clear_uid
};


#line 72
# Group AID_LOG checked by filesystem & logd
#line 72
# to permit control commands
#line 72

#line 72
allow system_app logd_socket:sock_file write;
#line 72
allow system_app logd:unix_stream_socket connectto;
#line 72

#line 72

#line 1 "external/sepolicy/drmserver.te"
# drmserver - DRM service
type drmserver, domain;
type drmserver_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init drmserver_exec:file { getattr open read execute };
#line 5
allow init drmserver:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow drmserver drmserver_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow drmserver init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init drmserver:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init drmserver:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init drmserver_exec:process drmserver;
#line 5

#line 5

#line 5
type drmserver_tmpfs, file_type;
#line 5
type_transition drmserver tmpfs:file drmserver_tmpfs;
#line 5
allow drmserver drmserver_tmpfs:file { read write };
#line 5

#line 5

typeattribute drmserver mlstrustedsubject;


#line 8
typeattribute drmserver netdomain;
#line 8


# Perform Binder IPC to system server.

#line 11
# Call the servicemanager and transfer references to it.
#line 11
allow drmserver servicemanager:binder { call transfer };
#line 11
# servicemanager performs getpidcon on clients.
#line 11
allow servicemanager drmserver:dir search;
#line 11
allow servicemanager drmserver:file { read open };
#line 11
allow servicemanager drmserver:process getattr;
#line 11
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 11
# all domains in domain.te.
#line 11


#line 12
# Call the server domain and optionally transfer references to it.
#line 12
allow drmserver system_server:binder { call transfer };
#line 12
# Allow the serverdomain to transfer references to the client on the reply.
#line 12
allow system_server drmserver:binder transfer;
#line 12
# Receive and use open files from the server.
#line 12
allow drmserver system_server:fd use;
#line 12


#line 13
# Call the server domain and optionally transfer references to it.
#line 13
allow drmserver appdomain:binder { call transfer };
#line 13
# Allow the serverdomain to transfer references to the client on the reply.
#line 13
allow appdomain drmserver:binder transfer;
#line 13
# Receive and use open files from the server.
#line 13
allow drmserver appdomain:fd use;
#line 13


#line 14
typeattribute drmserver binderservicedomain;
#line 14


# Perform Binder IPC to mediaserver

#line 17
# Call the server domain and optionally transfer references to it.
#line 17
allow drmserver mediaserver:binder { call transfer };
#line 17
# Allow the serverdomain to transfer references to the client on the reply.
#line 17
allow mediaserver drmserver:binder transfer;
#line 17
# Receive and use open files from the server.
#line 17
allow drmserver mediaserver:fd use;
#line 17


allow drmserver sdcard_type:dir search;
allow drmserver drm_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow drmserver drm_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow drmserver tee_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow drmserver app_data_file:file { read write getattr };
allow drmserver sdcard_type:file { read write getattr };

#line 25
allow drmserver efs_file:dir { open getattr read search ioctl };
#line 25
allow drmserver efs_file:{ file lnk_file } { getattr open read ioctl lock };
#line 25


type drmserver_socket, file_type;

# /data/app/tlcd_sock socket file.
# Clearly, /data/app is the most logical place to create a socket.  Not.
allow drmserver apk_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
type_transition drmserver apk_data_file:sock_file drmserver_socket;
allow drmserver drmserver_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow drmserver tee:unix_stream_socket connectto;
# Delete old socket file if present.
allow drmserver apk_data_file:sock_file unlink;

# After taking a video, drmserver looks at the video file.

#line 39
allow drmserver media_rw_data_file:dir { open getattr read search ioctl };
#line 39
allow drmserver media_rw_data_file:{ file lnk_file } { getattr open read ioctl lock };
#line 39


# Read resources from open apk files passed over Binder.
allow drmserver apk_data_file:file { read getattr };
allow drmserver asec_apk_file:file { read getattr };

# Read /data/data/com.android.providers.telephony files passed over Binder.
allow drmserver radio_data_file:file { read getattr };

allow drmserver drmserver_service:service_manager add;

# /oem access
allow drmserver oemfs:dir search;
allow drmserver oemfs:file { getattr open read ioctl lock };
#line 1 "external/sepolicy/file.te"
# Filesystem types
type labeledfs, fs_type;
type pipefs, fs_type;
type sockfs, fs_type;
type rootfs, fs_type;
type proc, fs_type;
# Security-sensitive proc nodes that should not be writable to most.
type proc_security, fs_type;
# proc, sysfs, or other nodes that permit configuration of kernel usermodehelpers.
type usermodehelper, fs_type, sysfs_type;
type qtaguid_proc, fs_type, mlstrustedobject;
type proc_bluetooth_writable, fs_type;
type proc_cpuinfo, fs_type;
type proc_net, fs_type;
type proc_sysrq, fs_type;
type selinuxfs, fs_type;
type cgroup, fs_type, mlstrustedobject;
type sysfs, fs_type, sysfs_type, mlstrustedobject;
type sysfs_writable, fs_type, sysfs_type, mlstrustedobject;
type sysfs_bluetooth_writable, fs_type, sysfs_type, mlstrustedobject;
type sysfs_nfc_power_writable, fs_type, sysfs_type, mlstrustedobject;
type sysfs_wake_lock, fs_type, sysfs_type;
# /sys/devices/system/cpu
type sysfs_devices_system_cpu, fs_type, sysfs_type;
# /sys/module/lowmemorykiller
type sysfs_lowmemorykiller, fs_type, sysfs_type;
type inotify, fs_type, mlstrustedobject;
type devpts, fs_type, mlstrustedobject;
type tmpfs, fs_type;
type shm, fs_type;
type mqueue, fs_type;
type fuse, sdcard_type, fs_type, mlstrustedobject;
type vfat, sdcard_type, fs_type, mlstrustedobject;
type sdcard_posix, sdcard_type, fs_type, mlstrustedobject;
#line 39

typealias fuse alias sdcard_internal;
typealias vfat alias sdcard_external;
type debugfs, fs_type, mlstrustedobject;
type pstorefs, fs_type;
type functionfs, fs_type;
type oemfs, fs_type, contextmount_type;
type usbfs, fs_type;

# File types
type unlabeled, file_type;
# Default type for anything under /system.
type system_file, file_type;
# /cores for coredumps on userdebug / eng builds
type coredump_file, file_type;
# Default type for anything under /data.
type system_data_file, file_type, data_file_type;
# /data/.layout_version or other installd-created files that
# are created in a system_data_file directory.
type install_data_file, file_type, data_file_type;
# /data/drm - DRM plugin data
type drm_data_file, file_type, data_file_type;
# /data/adb - adb debugging files
type adb_data_file, file_type, data_file_type;
# /data/anr - ANR traces
type anr_data_file, file_type, data_file_type, mlstrustedobject;
# /data/tombstones - core dumps
type tombstone_data_file, file_type, data_file_type;
# /data/app - user-installed apps
type apk_data_file, file_type, data_file_type;
type apk_tmp_file, file_type, data_file_type, mlstrustedobject;
# /data/app-private - forward-locked apps
type apk_private_data_file, file_type, data_file_type;
type apk_private_tmp_file, file_type, data_file_type, mlstrustedobject;
# /data/dalvik-cache
type dalvikcache_data_file, file_type, data_file_type;
# /data/dalvik-cache/profiles
type dalvikcache_profiles_data_file, file_type, data_file_type;
# /data/resource-cache
type resourcecache_data_file, file_type, data_file_type;
# /data/local - writable by shell
type shell_data_file, file_type, data_file_type;
# /data/gps
type gps_data_file, file_type, data_file_type;
# /data/property
type property_data_file, file_type, data_file_type;

# /data/misc subdirectories
type adb_keys_file, file_type, data_file_type;
type audio_data_file, file_type, data_file_type;
type bluetooth_data_file, file_type, data_file_type;
type camera_data_file, file_type, data_file_type;
type keychain_data_file, file_type, data_file_type;
type keystore_data_file, file_type, data_file_type;
type media_data_file, file_type, data_file_type;
type media_rw_data_file, file_type, data_file_type;
type misc_user_data_file, file_type, data_file_type;
type net_data_file, file_type, data_file_type;
type nfc_data_file, file_type, data_file_type;
type radio_data_file, file_type, data_file_type;
type shared_relro_file, file_type, data_file_type;
type systemkeys_data_file, file_type, data_file_type;
type vpn_data_file, file_type, data_file_type;
type wifi_data_file, file_type, data_file_type;
type zoneinfo_data_file, file_type, data_file_type;

# Compatibility with type names used in vanilla Android 4.3 and 4.4.
typealias audio_data_file alias audio_firmware_file;
# /data/data subdirectories - app sandboxes
type app_data_file, file_type, data_file_type;
# /data/data subdirectory for system UID apps.
type system_app_data_file, file_type, data_file_type;
# Compatibility with type name used in Android 4.3 and 4.4.
typealias app_data_file alias platform_app_data_file;
typealias app_data_file alias download_file;
# Default type for anything under /cache
type cache_file, file_type, mlstrustedobject;
# Type for /cache/.*\.{data|restore} and default
# type for anything under /cache/backup
type cache_backup_file, file_type, mlstrustedobject;
# Default type for anything under /efs
type efs_file, file_type;
# Type for wallpaper file.
type wallpaper_file, file_type, mlstrustedobject;
# /mnt/asec
type asec_apk_file, file_type, data_file_type;
# Elements of asec files (/mnt/asec) that are world readable
type asec_public_file, file_type, data_file_type;
# /data/app-asec
type asec_image_file, file_type, data_file_type;
# /data/backup and /data/secure/backup
type backup_data_file, file_type, data_file_type, mlstrustedobject;
# For /data/security
type security_file, file_type;
# All devices have bluetooth efs files. But they
# vary per device, so this type is used in per
# device policy
type bluetooth_efs_file, file_type;

# Socket types
type adbd_socket, file_type;
type bluetooth_socket, file_type;
type dnsproxyd_socket, file_type, mlstrustedobject;
type dumpstate_socket, file_type;
type fwmarkd_socket, file_type, mlstrustedobject;
type gps_socket, file_type;
type installd_socket, file_type;
type lmkd_socket, file_type;
type logd_debug, file_type;
type logd_socket, file_type;
type logdr_socket, file_type;
type logdw_socket, file_type;
type mdns_socket, file_type;
type mdnsd_socket, file_type;
type mtpd_socket, file_type;
type netd_socket, file_type;
type property_socket, file_type;
type racoon_socket, file_type;
type rild_socket, file_type;
type rild_debug_socket, file_type;
type system_wpa_socket, file_type;
type system_ndebug_socket, file_type;
type vold_socket, file_type;
type wpa_socket, file_type;
type zygote_socket, file_type;

# UART (for GPS) control proc file
type gps_control, file_type;

# Used by vold
type  proc_dirty_ratio, fs_type;

# Allow files to be created in their appropriate filesystems.
allow fs_type self:filesystem associate;
allow sysfs_type sysfs:filesystem associate;
allow file_type labeledfs:filesystem associate;
allow file_type tmpfs:filesystem associate;
allow file_type rootfs:filesystem associate;
allow dev_type tmpfs:filesystem associate;

# It's a bug to assign the file_type attribute and fs_type attribute
# to any type. Do not allow it.
#
# For example, the following is a bug:
#   type apk_data_file, file_type, data_file_type, fs_type;
# Should be:
#   type apk_data_file, file_type, data_file_type;
neverallow fs_type file_type:filesystem associate;
#line 1 "external/sepolicy/recovery.te"
# recovery console (used in recovery init.rc for /sbin/recovery)

# Declare the domain unconditionally so we can always reference it
# in neverallow rules.
type recovery, domain;

# But the allow rules are only included in the recovery policy.
# Otherwise recovery is only allowed the domain rules.
#line 102

#line 1 "external/sepolicy/install_recovery.te"
# service flash_recovery in init.rc
type install_recovery, domain;
type install_recovery_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init install_recovery_exec:file { getattr open read execute };
#line 5
allow init install_recovery:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow install_recovery install_recovery_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow install_recovery init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init install_recovery:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init install_recovery:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init install_recovery_exec:process install_recovery;
#line 5

#line 5

#line 5
type install_recovery_tmpfs, file_type;
#line 5
type_transition install_recovery tmpfs:file install_recovery_tmpfs;
#line 5
allow install_recovery install_recovery_tmpfs:file { read write };
#line 5

#line 5


allow install_recovery self:capability dac_override;

# /system/bin/install-recovery.sh is a shell script.
# Needs to execute /system/bin/sh
allow install_recovery shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Execute /system/bin/applypatch
allow install_recovery system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Update the recovery block device
# TODO: Limit this to only recovery block device when we
# create an appropriate label for it.
allow install_recovery block_device:dir search;
allow install_recovery block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Create and delete /cache/saved.file
allow install_recovery cache_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow install_recovery cache_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Write to /proc/sys/vm/drop_caches
# TODO: create a specific label for this file instead of allowing
# write for all /proc files.
allow install_recovery proc:file { open append write };
#line 1 "external/sepolicy/surfaceflinger.te"
# surfaceflinger - display compositor service
type surfaceflinger, domain;
type surfaceflinger_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init surfaceflinger_exec:file { getattr open read execute };
#line 5
allow init surfaceflinger:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow surfaceflinger surfaceflinger_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow surfaceflinger init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init surfaceflinger:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init surfaceflinger:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init surfaceflinger_exec:process surfaceflinger;
#line 5

#line 5

#line 5
type surfaceflinger_tmpfs, file_type;
#line 5
type_transition surfaceflinger tmpfs:file surfaceflinger_tmpfs;
#line 5
allow surfaceflinger surfaceflinger_tmpfs:file { read write };
#line 5

#line 5

typeattribute surfaceflinger mlstrustedsubject;

# Talk to init over the property socket.

#line 9
allow surfaceflinger property_socket:sock_file write;
#line 9
allow surfaceflinger init:unix_stream_socket connectto;
#line 9


# Perform Binder IPC.

#line 12
# Call the servicemanager and transfer references to it.
#line 12
allow surfaceflinger servicemanager:binder { call transfer };
#line 12
# servicemanager performs getpidcon on clients.
#line 12
allow servicemanager surfaceflinger:dir search;
#line 12
allow servicemanager surfaceflinger:file { read open };
#line 12
allow servicemanager surfaceflinger:process getattr;
#line 12
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 12
# all domains in domain.te.
#line 12


#line 13
# Call the server domain and optionally transfer references to it.
#line 13
allow surfaceflinger binderservicedomain:binder { call transfer };
#line 13
# Allow the serverdomain to transfer references to the client on the reply.
#line 13
allow binderservicedomain surfaceflinger:binder transfer;
#line 13
# Receive and use open files from the server.
#line 13
allow surfaceflinger binderservicedomain:fd use;
#line 13


#line 14
# Call the server domain and optionally transfer references to it.
#line 14
allow surfaceflinger appdomain:binder { call transfer };
#line 14
# Allow the serverdomain to transfer references to the client on the reply.
#line 14
allow appdomain surfaceflinger:binder transfer;
#line 14
# Receive and use open files from the server.
#line 14
allow surfaceflinger appdomain:fd use;
#line 14


#line 15
# Call the server domain and optionally transfer references to it.
#line 15
allow surfaceflinger bootanim:binder { call transfer };
#line 15
# Allow the serverdomain to transfer references to the client on the reply.
#line 15
allow bootanim surfaceflinger:binder transfer;
#line 15
# Receive and use open files from the server.
#line 15
allow surfaceflinger bootanim:fd use;
#line 15


#line 16
typeattribute surfaceflinger binderservicedomain;
#line 16


# Binder IPC to bu, presently runs in adbd domain.

#line 19
# Call the server domain and optionally transfer references to it.
#line 19
allow surfaceflinger adbd:binder { call transfer };
#line 19
# Allow the serverdomain to transfer references to the client on the reply.
#line 19
allow adbd surfaceflinger:binder transfer;
#line 19
# Receive and use open files from the server.
#line 19
allow surfaceflinger adbd:fd use;
#line 19


# Read /proc/pid files for Binder clients.

#line 22
allow surfaceflinger binderservicedomain:dir { open getattr read search ioctl };
#line 22
allow surfaceflinger binderservicedomain:{ file lnk_file } { getattr open read ioctl lock };
#line 22


#line 23
allow surfaceflinger appdomain:dir { open getattr read search ioctl };
#line 23
allow surfaceflinger appdomain:{ file lnk_file } { getattr open read ioctl lock };
#line 23


# Access the GPU.
allow surfaceflinger gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access /dev/graphics/fb0.
allow surfaceflinger graphics_device:dir search;
allow surfaceflinger graphics_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Access /dev/video1.
allow surfaceflinger video_device:dir { open getattr read search ioctl };
allow surfaceflinger video_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Create and use netlink kobject uevent sockets.
allow surfaceflinger self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Set properties.
allow surfaceflinger system_prop:property_service set;
allow surfaceflinger ctl_bootanim_prop:property_service set;

# Use open files supplied by an app.
allow surfaceflinger appdomain:fd use;
allow surfaceflinger app_data_file:file { read write };

# Use open file provided by bootanim.
allow surfaceflinger bootanim:fd use;

# Allow a dumpstate triggered screenshot

#line 51
# Call the server domain and optionally transfer references to it.
#line 51
allow surfaceflinger dumpstate:binder { call transfer };
#line 51
# Allow the serverdomain to transfer references to the client on the reply.
#line 51
allow dumpstate surfaceflinger:binder transfer;
#line 51
# Receive and use open files from the server.
#line 51
allow surfaceflinger dumpstate:fd use;
#line 51


#line 52
# Call the server domain and optionally transfer references to it.
#line 52
allow surfaceflinger shell:binder { call transfer };
#line 52
# Allow the serverdomain to transfer references to the client on the reply.
#line 52
allow shell surfaceflinger:binder transfer;
#line 52
# Receive and use open files from the server.
#line 52
allow surfaceflinger shell:fd use;
#line 52


#line 53
allow surfaceflinger dumpstate:dir { open getattr read search ioctl };
#line 53
allow surfaceflinger dumpstate:{ file lnk_file } { getattr open read ioctl lock };
#line 53


# Needed on some devices for playing DRM protected content,
# but seems expected and appropriate for all devices.
allow surfaceflinger tee:unix_stream_socket connectto;
allow surfaceflinger tee_device:chr_file { { getattr open read ioctl lock } { open append write } };

allow surfaceflinger surfaceflinger_service:service_manager add;

###
### Neverallow rules
###
### surfaceflinger should NEVER do any of this

# Do not allow accessing SDcard files as unsafe ejection could
# cause the kernel to kill the process.
neverallow surfaceflinger sdcard_type:file { { getattr open read ioctl lock } { open append write } };
#line 1 "external/sepolicy/radio.te"
# phone subsystem
type radio, domain;

#line 3
typeattribute radio appdomain;
#line 3
# Label ashmem objects with our own unique type.
#line 3

#line 3
type radio_tmpfs, file_type;
#line 3
type_transition radio tmpfs:file radio_tmpfs;
#line 3
allow radio radio_tmpfs:file { read write };
#line 3

#line 3
# Map with PROT_EXEC.
#line 3
allow radio radio_tmpfs:file execute;
#line 3


#line 4
typeattribute radio netdomain;
#line 4


#line 5
typeattribute radio bluetoothdomain;
#line 5


#line 6
typeattribute radio binderservicedomain;
#line 6


# Talks to init via the property socket.

#line 9
allow radio property_socket:sock_file write;
#line 9
allow radio init:unix_stream_socket connectto;
#line 9


# Talks to rild via the rild socket.

#line 12
allow radio rild_socket:sock_file write;
#line 12
allow radio rild:unix_stream_socket connectto;
#line 12


# Data file accesses.
allow radio radio_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow radio radio_data_file:{ file lnk_file sock_file fifo_file } { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

allow radio alarm_device:chr_file { { getattr open read ioctl lock } { open append write } };

allow radio net_data_file:dir search;
allow radio net_data_file:file { getattr open read ioctl lock };

# Property service
allow radio radio_prop:property_service set;
allow radio net_radio_prop:property_service set;
allow radio system_radio_prop:property_service set;
auditallow radio net_radio_prop:property_service set;
auditallow radio system_radio_prop:property_service set;

# ctl interface
allow radio ctl_rildaemon_prop:property_service set;

allow radio radio_service:service_manager add;
#line 1 "external/sepolicy/hostapd.te"
# userspace wifi access points
type hostapd, domain;
type hostapd_exec, exec_type, file_type;


#line 5
typeattribute hostapd netdomain;
#line 5


allow hostapd self:capability { net_admin net_raw setuid setgid };
allow hostapd self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow hostapd self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow hostapd self:netlink_route_socket nlmsg_write;

allow hostapd wifi_data_file:file { { getattr open read ioctl lock } { open append write } };
allow hostapd wifi_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
type_transition hostapd wifi_data_file:dir wpa_socket "sockets";
type_transition hostapd wifi_data_file:dir wpa_socket "hostapd";
allow hostapd wpa_socket:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow hostapd wpa_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow hostapd netd:fd use;
allow hostapd netd:udp_socket { read write };
allow hostapd netd:fifo_file { read write };
# TODO: Investigate whether these inherited sockets should be closed on exec.
allow hostapd netd:netlink_kobject_uevent_socket { read write };
allow hostapd netd:netlink_nflog_socket { read write };
allow hostapd netd:netlink_route_socket { read write };
allow hostapd netd:unix_stream_socket { read write };
allow hostapd netd:unix_dgram_socket { read write };
#line 1 "external/sepolicy/logd.te"
# android user-space log manager
type logd, domain;
type logd_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init logd_exec:file { getattr open read execute };
#line 5
allow init logd:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow logd logd_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow logd init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init logd:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init logd:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init logd_exec:process logd;
#line 5

#line 5

#line 5
type logd_tmpfs, file_type;
#line 5
type_transition logd tmpfs:file logd_tmpfs;
#line 5
allow logd logd_tmpfs:file { read write };
#line 5

#line 5


allow logd self:capability { setuid setgid sys_nice audit_control };
allow logd self:capability2 syslog;
allow logd self:netlink_audit_socket { { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_write };
allow logd kernel:system syslog_read;
allow logd kmsg_device:chr_file { open append write };


#line 13
allow logd domain:dir { open getattr read search ioctl };
#line 13
allow logd domain:{ file lnk_file } { getattr open read ioctl lock };
#line 13



#line 15
  # Debug output
#line 15
  type_transition logd device:file logd_debug;
#line 15
  allow logd device:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
#line 15
  allow logd logd_debug:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
#line 20


###
### Neverallow rules
###
### logd should NEVER do any of this

# Block device access.
neverallow logd dev_type:blk_file { read write };

# ptrace any other app
neverallow logd domain:process ptrace;

# Write to /system.
neverallow logd system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Write to files in /data/data or system files on /data
neverallow logd { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
#line 1 "external/sepolicy/uncrypt.te"
# uncrypt
type uncrypt, domain;
type uncrypt_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init uncrypt_exec:file { getattr open read execute };
#line 5
allow init uncrypt:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow uncrypt uncrypt_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow uncrypt init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init uncrypt:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init uncrypt:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init uncrypt_exec:process uncrypt;
#line 5

#line 5

#line 5
type uncrypt_tmpfs, file_type;
#line 5
type_transition uncrypt tmpfs:file uncrypt_tmpfs;
#line 5
allow uncrypt uncrypt_tmpfs:file { read write };
#line 5

#line 5


allow uncrypt self:capability dac_override;

# Read OTA zip file from /data/data/com.google.android.gsf/app_download

#line 10
allow uncrypt app_data_file:dir { open getattr read search ioctl };
#line 10
allow uncrypt app_data_file:{ file lnk_file } { getattr open read ioctl lock };
#line 10



#line 12
  # For debugging, allow /data/local/tmp access
#line 12
  
#line 12
allow uncrypt shell_data_file:dir { open getattr read search ioctl };
#line 12
allow uncrypt shell_data_file:{ file lnk_file } { getattr open read ioctl lock };
#line 12

#line 15


# Create tmp file /cache/recovery/command.tmp
# Read /cache/recovery/command
# Rename /cache/recovery/command.tmp to /cache/recovery/command
allow uncrypt cache_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow uncrypt cache_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Set a property to reboot the device.

#line 24
allow uncrypt property_socket:sock_file write;
#line 24
allow uncrypt init:unix_stream_socket connectto;
#line 24

allow uncrypt powerctl_prop:property_service set;

# Raw writes to block device
allow uncrypt self:capability sys_rawio;
allow uncrypt block_device:blk_file { open append write };
allow uncrypt block_device:dir { open getattr read search ioctl };

# Access userdata block device.
allow uncrypt userdata_block_device:blk_file { { getattr open read ioctl lock } { open append write } };
auditallow uncrypt userdata_block_device:blk_file { { getattr open read ioctl lock } { open append write } };
#line 1 "external/sepolicy/racoon.te"
# IKE key management daemon
type racoon, domain;
type racoon_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init racoon_exec:file { getattr open read execute };
#line 5
allow init racoon:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow racoon racoon_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow racoon init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init racoon:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init racoon:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init racoon_exec:process racoon;
#line 5

#line 5

#line 5
type racoon_tmpfs, file_type;
#line 5
type_transition racoon tmpfs:file racoon_tmpfs;
#line 5
allow racoon racoon_tmpfs:file { read write };
#line 5

#line 5

typeattribute racoon mlstrustedsubject;


#line 8
typeattribute racoon netdomain;
#line 8



#line 10
# Call the servicemanager and transfer references to it.
#line 10
allow racoon servicemanager:binder { call transfer };
#line 10
# servicemanager performs getpidcon on clients.
#line 10
allow servicemanager racoon:dir search;
#line 10
allow servicemanager racoon:file { read open };
#line 10
allow servicemanager racoon:process getattr;
#line 10
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 10
# all domains in domain.te.
#line 10


allow racoon tun_device:chr_file { getattr open read ioctl lock };
allow racoon cgroup:dir { add_name create };
allow racoon kernel:system module_request;

allow racoon self:key_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow racoon self:tun_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow racoon self:capability { net_admin net_bind_service net_raw setuid };

# XXX: should we give ip-up-vpn its own label (currently racoon domain)
allow racoon system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow racoon vpn_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow racoon vpn_data_file:dir { open search write add_name remove_name };


#line 25
  allow keystore racoon:dir search;
#line 25
  allow keystore racoon:file { read open };
#line 25
  allow keystore racoon:process getattr;
#line 25
  
#line 25
# Call the server domain and optionally transfer references to it.
#line 25
allow racoon keystore:binder { call transfer };
#line 25
# Allow the serverdomain to transfer references to the client on the reply.
#line 25
allow keystore racoon:binder transfer;
#line 25
# Receive and use open files from the server.
#line 25
allow racoon keystore:fd use;
#line 25

#line 25


# Racoon (VPN) has a restricted set of permissions from the default.
allow racoon keystore:keystore_key {
	get
	sign
	verify
};
#line 1 "external/sepolicy/watchdogd.te"
# watchdogd seclabel is specified in init.<board>.rc
type watchdogd, domain;
allow watchdogd self:capability mknod;
allow watchdogd device:dir { add_name write remove_name };
allow watchdogd watchdog_device:chr_file { { getattr open read ioctl lock } { open append write } };
# because of /dev/__kmsg__ and /dev/__null__

#line 7
type_transition watchdogd device:chr_file klog_device "__kmsg__";
#line 7
allow watchdogd klog_device:chr_file { create open write unlink };
#line 7
allow watchdogd device:dir { write add_name remove_name };
#line 7

type_transition watchdogd device:chr_file null_device "__null__";
allow watchdogd null_device:chr_file { create unlink };
#line 1 "external/sepolicy/debuggerd.te"
# debugger interface
type debuggerd, domain;
type debuggerd_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init debuggerd_exec:file { getattr open read execute };
#line 5
allow init debuggerd:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow debuggerd debuggerd_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow debuggerd init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init debuggerd:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init debuggerd:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init debuggerd_exec:process debuggerd;
#line 5

#line 5

#line 5
type debuggerd_tmpfs, file_type;
#line 5
type_transition debuggerd tmpfs:file debuggerd_tmpfs;
#line 5
allow debuggerd debuggerd_tmpfs:file { read write };
#line 5

#line 5

typeattribute debuggerd mlstrustedsubject;
allow debuggerd self:capability { dac_override sys_ptrace chown kill fowner };
allow debuggerd self:capability2 { syslog };
allow debuggerd domain:dir { open getattr read search ioctl };
allow debuggerd domain:file { getattr open read ioctl lock };
allow debuggerd domain:lnk_file read;
allow debuggerd { domain -init -ueventd -watchdogd -healthd -adbd -keystore }:process ptrace;

#line 13
allow debuggerd security_file:dir { open getattr read search ioctl };
#line 13
allow debuggerd security_file:file { getattr open read ioctl lock };
#line 13

allow debuggerd system_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow debuggerd system_data_file:dir relabelfrom;
allow debuggerd tombstone_data_file:dir relabelto;
allow debuggerd tombstone_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow debuggerd tombstone_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow debuggerd shared_relro_file:dir { open getattr read search ioctl };
allow debuggerd shared_relro_file:file { getattr open read ioctl lock };
allow debuggerd domain:process { sigstop signal };
allow debuggerd exec_type:file { getattr open read ioctl lock };
# Access app library
allow debuggerd system_data_file:file open;

# Connect to system_server via /data/system/ndebugsocket.

#line 27
allow debuggerd system_ndebug_socket:sock_file write;
#line 27
allow debuggerd system_server:unix_stream_socket connectto;
#line 27



#line 29
  allow debuggerd input_device:dir { open getattr read search ioctl };
#line 29
  allow debuggerd input_device:chr_file { { getattr open read ioctl lock } { open append write } };
#line 32


# logd access

#line 35

#line 35
allow debuggerd logdr_socket:sock_file write;
#line 35
allow debuggerd logd:unix_stream_socket connectto;
#line 35

#line 35

#line 1 "external/sepolicy/net.te"
# Network types
type node, node_type;
type netif, netif_type;
type port, port_type;

# Use network sockets.
allow netdomain self:tcp_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
allow netdomain self:{ udp_socket rawip_socket } { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
# Connect to ports.
allow netdomain port_type:tcp_socket name_connect;
# Bind to ports.
allow netdomain node_type:{ tcp_socket udp_socket } node_bind;
allow netdomain port_type:udp_socket name_bind;
allow netdomain port_type:tcp_socket name_bind;
# See changes to the routing table.
allow netdomain self:netlink_route_socket { { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_read };

# Talks to netd via dnsproxyd socket.

#line 19
allow netdomain dnsproxyd_socket:sock_file write;
#line 19
allow netdomain netd:unix_stream_socket connectto;
#line 19


# Talks to netd via fwmarkd socket.

#line 22
allow netdomain fwmarkd_socket:sock_file write;
#line 22
allow netdomain netd:unix_stream_socket connectto;
#line 22


# Connect to mdnsd via mdnsd socket.

#line 25
allow netdomain mdnsd_socket:sock_file write;
#line 25
allow netdomain mdnsd:unix_stream_socket connectto;
#line 25

#line 1 "external/sepolicy/property.te"
type default_prop, property_type;
type shell_prop, property_type;
type debug_prop, property_type;
type debuggerd_prop, property_type;
type dhcp_prop, property_type;
type fingerprint_prop, property_type;
type radio_prop, property_type;
type net_radio_prop, property_type;
type system_radio_prop, property_type;
type system_prop, property_type;
type vold_prop, property_type;
type ctl_bootanim_prop, property_type;
type ctl_default_prop, property_type;
type ctl_dhcp_pan_prop, property_type;
type ctl_dumpstate_prop, property_type;
type ctl_fuse_prop, property_type;
type ctl_mdnsd_prop, property_type;
type ctl_rildaemon_prop, property_type;
type ctl_bugreport_prop, property_type;
type audio_prop, property_type;
type logd_prop, property_type;
type security_prop, property_type;
type bluetooth_prop, property_type;
type pan_result_prop, property_type;
type powerctl_prop, property_type;
type nfc_prop, property_type;
#line 1 "external/sepolicy/bluetooth.te"
# bluetooth subsystem
type bluetooth, domain;

#line 3
typeattribute bluetooth appdomain;
#line 3
# Label ashmem objects with our own unique type.
#line 3

#line 3
type bluetooth_tmpfs, file_type;
#line 3
type_transition bluetooth tmpfs:file bluetooth_tmpfs;
#line 3
allow bluetooth bluetooth_tmpfs:file { read write };
#line 3

#line 3
# Map with PROT_EXEC.
#line 3
allow bluetooth bluetooth_tmpfs:file execute;
#line 3


#line 4
typeattribute bluetooth netdomain;
#line 4


# Data file accesses.
allow bluetooth bluetooth_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow bluetooth bluetooth_data_file:{ file lnk_file sock_file fifo_file } { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Socket creation under /data/misc/bluedroid.
type_transition bluetooth bluetooth_data_file:sock_file bluetooth_socket;
allow bluetooth bluetooth_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# bluetooth factory file accesses.

#line 15
allow bluetooth bluetooth_efs_file:dir { open getattr read search ioctl };
#line 15
allow bluetooth bluetooth_efs_file:{ file lnk_file } { getattr open read ioctl lock };
#line 15


# Device accesses.
allow bluetooth { tun_device uhid_device hci_attach_dev }:chr_file { { getattr open read ioctl lock } { open append write } };

# Other domains that can create and use bluetooth sockets.
# SELinux does not presently define a specific socket class for
# bluetooth sockets, nor does it distinguish among the bluetooth protocols.
# TODO: This should no longer be needed with bluedroid for bluetooth
# but may be getting used for other non-bluetooth sockets that has no
# specific class defined.  Consider taking to specific domains.
allow { bluetoothdomain -untrusted_app -isolated_app -shell } self:socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
neverallow { untrusted_app isolated_app shell } { untrusted_app isolated_app shell }:socket *;

# sysfs access.
allow bluetooth sysfs_bluetooth_writable:file { { getattr open read ioctl lock } { open append write } };
allow bluetooth self:capability net_admin;
allow bluetooth self:capability2 wake_alarm;

# Allow clients to use a socket provided by the bluetooth app.
# TODO:  See if this is still required under bluedroid.
allow bluetoothdomain bluetooth:unix_stream_socket { getopt setopt getattr read write ioctl shutdown };

# tethering
allow bluetooth self:tun_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow bluetooth efs_file:dir search;

# Talk to init over the property socket.

#line 43
allow bluetooth property_socket:sock_file write;
#line 43
allow bluetooth init:unix_stream_socket connectto;
#line 43


# proc access.
allow bluetooth proc_bluetooth_writable:file { { getattr open read ioctl lock } { open append write } };

# Allow write access to bluetooth specific properties
allow bluetooth bluetooth_prop:property_service set;
allow bluetooth pan_result_prop:property_service set;
allow bluetooth ctl_dhcp_pan_prop:property_service set;

###
### Neverallow rules
###
### These are things that the bluetooth app should NEVER be able to do
###

# Superuser capabilities.
# bluetooth requires net_admin and wake_alarm.
neverallow bluetooth self:capability ~net_admin;
neverallow bluetooth self:capability2 ~wake_alarm;
#line 1 "external/sepolicy/domain.te"
# Rules for all domains.

# Allow reaping by init.
allow domain init:process sigchld;

# Read access to properties mapping.
allow domain kernel:fd use;
allow domain tmpfs:file { read getattr };

# Search /storage/emulated tmpfs mount.
allow domain tmpfs:dir { open getattr read search ioctl };

# Intra-domain accesses.
allow domain self:process {
    fork
    sigchld
    sigkill
    sigstop
    signull
    signal
    getsched
    setsched
    getsession
    getpgid
    setpgid
    getcap
    setcap
    getattr
    setrlimit
};
allow domain self:fd use;
allow domain self:dir { open getattr read search ioctl };
allow domain self:lnk_file { getattr open read ioctl lock };
allow domain self:{ fifo_file file } { { getattr open read ioctl lock } { open append write } };
allow domain self:unix_dgram_socket { { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } } sendto };
allow domain self:unix_stream_socket { { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } } connectto };

# Inherit or receive open files from others.
allow domain init:fd use;
allow domain system_server:fd use;

# Connect to adbd and use a socket transferred from it.
# This is used for e.g. adb backup/restore.
allow domain adbd:unix_stream_socket connectto;
allow domain adbd:fd use;
allow domain adbd:unix_stream_socket { getattr getopt read write shutdown };


#line 48
  # Same as adbd rules above, except allow su to do the same thing
#line 48
  allow domain su:unix_stream_socket connectto;
#line 48
  allow domain su:fd use;
#line 48
  allow domain su:unix_stream_socket { getattr getopt read write shutdown };
#line 48

#line 48
  
#line 48
# Call the server domain and optionally transfer references to it.
#line 48
allow domain su:binder { call transfer };
#line 48
# Allow the serverdomain to transfer references to the client on the reply.
#line 48
allow su domain:binder transfer;
#line 48
# Receive and use open files from the server.
#line 48
allow domain su:fd use;
#line 48

#line 48

#line 48
  # Running something like "pm dump com.android.bluetooth" requires
#line 48
  # fifo writes
#line 48
  allow domain su:fifo_file { write getattr };
#line 48

#line 48
  # allow "gdbserver --attach" to work for su.
#line 48
  allow domain su:process sigchld;
#line 48

#line 48
  # Allow writing coredumps to /cores/*
#line 48
  allow domain coredump_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
#line 48
  allow domain coredump_file:dir { { open getattr read search ioctl } add_name write };
#line 66


###
### Talk to debuggerd.
###
allow domain debuggerd:process sigchld;
allow domain debuggerd:unix_stream_socket connectto;

# Root fs.
allow domain rootfs:dir { open getattr read search ioctl };
allow domain rootfs:file { getattr open read ioctl lock };
allow domain rootfs:lnk_file { getattr open read ioctl lock };

# Device accesses.
allow domain device:dir search;
allow domain dev_type:lnk_file { getattr open read ioctl lock };
allow domain devpts:dir search;
allow domain device:file read;
allow domain socket_device:dir { open getattr read search ioctl };
allow domain owntty_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain null_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain zero_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain ashmem_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain binder_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain ptmx_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain log_device:dir search;
allow domain log_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain alarm_device:chr_file { getattr open read ioctl lock };
allow domain urandom_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain random_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow domain properties_device:file { getattr open read ioctl lock };

# logd access

#line 99

#line 99
  allow domain logd_debug:file { open append write };
#line 99

#line 99

#line 99
allow domain logdw_socket:sock_file write;
#line 99
allow domain logd:unix_dgram_socket sendto;
#line 99

#line 99


# Filesystem accesses.
allow domain fs_type:filesystem getattr;
allow domain fs_type:dir getattr;

# System file accesses.
allow domain system_file:dir { open getattr read search ioctl };
allow domain system_file:file { getattr open read ioctl lock };
allow domain system_file:file execute;
allow domain system_file:lnk_file { getattr open read ioctl lock };

# Read files already opened under /data.
allow domain system_data_file:dir { search getattr };
allow domain system_data_file:file { getattr read };
allow domain system_data_file:lnk_file { getattr open read ioctl lock };

# Read apk files under /data/app.
allow domain apk_data_file:dir { getattr search };
allow domain apk_data_file:file { getattr open read ioctl lock };
allow domain apk_data_file:lnk_file { getattr open read ioctl lock };

# Read /data/dalvik-cache.
allow domain dalvikcache_data_file:dir { search getattr };
allow domain dalvikcache_data_file:file { getattr open read ioctl lock };

# Read already opened /cache files.
allow domain cache_file:dir { open getattr read search ioctl };
allow domain cache_file:file { getattr read };
allow domain cache_file:lnk_file { getattr open read ioctl lock };

# Read timezone related information

#line 131
allow domain zoneinfo_data_file:dir { open getattr read search ioctl };
#line 131
allow domain zoneinfo_data_file:{ file lnk_file } { getattr open read ioctl lock };
#line 131


# For /acct/uid/*/tasks.
allow domain cgroup:dir { search write };
allow domain cgroup:file { open append write };

#Allow access to ion memory allocation device
allow domain ion_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Read access to pseudo filesystems.

#line 141
allow domain proc:dir { open getattr read search ioctl };
#line 141
allow domain proc:{ file lnk_file } { getattr open read ioctl lock };
#line 141


#line 142
allow domain sysfs:dir { open getattr read search ioctl };
#line 142
allow domain sysfs:{ file lnk_file } { getattr open read ioctl lock };
#line 142


#line 143
allow domain sysfs_devices_system_cpu:dir { open getattr read search ioctl };
#line 143
allow domain sysfs_devices_system_cpu:{ file lnk_file } { getattr open read ioctl lock };
#line 143


#line 144
allow domain inotify:dir { open getattr read search ioctl };
#line 144
allow domain inotify:{ file lnk_file } { getattr open read ioctl lock };
#line 144


#line 145
allow domain cgroup:dir { open getattr read search ioctl };
#line 145
allow domain cgroup:{ file lnk_file } { getattr open read ioctl lock };
#line 145


#line 146
allow domain proc_net:dir { open getattr read search ioctl };
#line 146
allow domain proc_net:{ file lnk_file } { getattr open read ioctl lock };
#line 146

allow domain proc_cpuinfo:file { getattr open read ioctl lock };

# debugfs access
allow domain debugfs:dir { open getattr read search ioctl };
allow domain debugfs:file { open append write };

# Get SELinux enforcing status.
allow domain selinuxfs:dir { open getattr read search ioctl };
allow domain selinuxfs:file { getattr open read ioctl lock };

# /data/security files
allow domain security_file:dir { search getattr };
allow domain security_file:file getattr;
allow domain security_file:lnk_file { getattr open read ioctl lock };

# World readable asec image contents
allow domain asec_public_file:file { getattr open read ioctl lock };
allow domain { asec_public_file asec_apk_file }:dir { open getattr read search ioctl };

allow domain servicemanager:service_manager list;
allow domain service_manager_type:service_manager find;

###
### neverallow rules
###

# Do not allow any confined domain to create new unlabeled files.
neverallow { domain -unconfineddomain -recovery } unlabeled:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } create;

# Limit ability to ptrace or read sensitive /proc/pid files of processes
# with other UIDs to these whitelisted domains.
neverallow { domain -debuggerd -vold -dumpstate -system_server } self:capability sys_ptrace;

# Limit device node creation to these whitelisted domains.
neverallow { domain -kernel -init -recovery -ueventd -watchdogd -healthd -vold -uncrypt } self:capability mknod;

attribute rmt_placeholder;
# Limit raw I/O to these whitelisted domains.
neverallow { domain -kernel -init -recovery -ueventd -watchdogd -healthd -vold -uncrypt -tee -rmt_placeholder } self:capability sys_rawio;

# No process can map low memory (< CONFIG_LSM_MMAP_MIN_ADDR).
neverallow domain self:memprotect mmap_zero;

# No domain needs mac_override as it is unused by SELinux.
neverallow domain self:capability2 mac_override;

# Only recovery needs mac_admin to set contexts not defined in current policy.
neverallow { domain -recovery } self:capability2 mac_admin;

# Only init should be able to load SELinux policies.
# The first load technically occurs while still in the kernel domain,
# but this does not trigger a denial since there is no policy yet.
# Policy reload requires allowing this to the init domain.
neverallow { domain -init } kernel:security load_policy;

# Only init and the system_server can set selinux.reload_policy 1
# to trigger a policy reload.
neverallow { domain -init -system_server } security_prop:property_service set;

# Only init and system_server can write to /data/security, where runtime
# policy updates live.
# Only init can relabel /data/security (for init.rc restorecon_recursive /data).
neverallow { domain -init } security_file:{ dir file lnk_file } { relabelfrom relabelto };
# Only init and system_server can create/setattr directories with this type.
# init is for init.rc mkdir /data/security.
# system_server is for creating subdirectories under /data/security.
neverallow { domain -init -system_server } security_file:dir { create setattr };
# Only system_server can create subdirectories and files under /data/security.
neverallow { domain -system_server -recovery } security_file:dir { rename write add_name remove_name rmdir };
neverallow { domain -system_server -recovery } security_file:file { create setattr write append unlink link rename };
neverallow { domain -system_server -recovery } security_file:lnk_file { create setattr unlink rename };

# Only init prior to switching context should be able to set enforcing mode.
# init starts in kernel domain and switches to init domain via setcon in
# the init.rc, so the setenforce occurs while still in kernel. After
# switching domains, there is never any need to setenforce again by init.
neverallow domain kernel:security setenforce;
neverallow { domain -kernel } kernel:security setcheckreqprot;

# No booleans in AOSP policy, so no need to ever set them.
neverallow domain kernel:security setbool;

# Adjusting the AVC cache threshold.
# Not presently allowed to anything in policy, but possibly something
# that could be set from init.rc.
neverallow { domain -init } kernel:security setsecparam;

# Only init, ueventd and system_server should be able to access HW RNG
neverallow { domain -init -system_server -ueventd -unconfineddomain } hw_random_device:chr_file *;

# Ensure that all entrypoint executables are in exec_type.
neverallow domain { file_type -exec_type }:file entrypoint;

# Ensure that nothing in userspace can access /dev/mem or /dev/kmem
neverallow { domain -rmt_placeholder -kernel -ueventd -init } kmem_device:chr_file *;
neverallow { domain -rmt_placeholder } kmem_device:chr_file ~{ create relabelto unlink setattr };

# Only init should be able to configure kernel usermodehelpers or
# security-sensitive proc settings.
neverallow { domain -init } usermodehelper:file { append write };
neverallow { domain -init } proc_security:file { append write };

# No domain should be allowed to ptrace init.
neverallow domain init:process ptrace;

# Init can't receive binder calls. If this neverallow rule is being
# triggered, it's probably due to a service with no SELinux domain.
neverallow domain init:binder call;

# Don't allow raw read/write/open access to block_device
# Rather force a relabel to a more specific type
neverallow { domain -kernel -init -recovery -vold -uncrypt -install_recovery } block_device:blk_file { open read write };

# Don't allow raw read/write/open access to generic devices.
# Rather force a relabel to a more specific type.
# ueventd is exempt from this, as its managing these devices.
neverallow { domain -unconfineddomain -ueventd -recovery } device:chr_file { open read write };

# Limit what domains can mount filesystems or change their mount flags.
# sdcard_type / vfat is exempt as a larger set of domains need
# this capability, including device-specific domains.
neverallow { domain -kernel -init -recovery -vold -zygote } { fs_type -sdcard_type }:filesystem { mount remount relabelfrom relabelto };

#
# Assert that, to the extent possible, we're not loading executable content from
# outside the rootfs or /system partition except for a few whitelisted domains.
#
neverallow {
    domain
    -appdomain
    -dumpstate
    -shell
    -su
    -system_server
    -zygote
} { file_type -system_file -exec_type }:file execute;
neverallow {
    domain
    -appdomain # for oemfs
    -recovery # for /tmp/update_binary in tmpfs
} { fs_type -rootfs }:file execute;

# Only the init property service should write to /data/property.
neverallow { domain -init -recovery } property_data_file:dir { create setattr relabelfrom rename write add_name remove_name rmdir };
neverallow { domain -init -recovery } property_data_file:file { create setattr relabelfrom write append unlink link rename };

# Only recovery should be doing writes to /system
neverallow { domain -recovery } { system_file exec_type }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Nothing should be writing to files in the rootfs.
neverallow { domain -recovery } rootfs:file { create write setattr relabelto append unlink link rename };

# Restrict context mounts to specific types marked with
# the contextmount_type attribute.
neverallow domain {fs_type -contextmount_type -sdcard_posix}:filesystem relabelto;
#line 306


# Ensure that context mount types are not writable, to ensure that
# the write to /system restriction above is not bypassed via context=
# mount to another type.
neverallow { domain -recovery } contextmount_type:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Do not allow service_manager add for default_android_service.
# Instead domains should use a more specific type such as
# system_app_service rather than the generic type.
# New service_types are defined in service.te and new mappings
# from service name to service_type are defined in service_contexts.
neverallow domain default_android_service:service_manager add;

neverallow { domain -init -recovery -system_server } frp_block_device:blk_file { { getattr open read ioctl lock } { open append write } };
#line 1 "external/sepolicy/zygote.te"
# zygote
type zygote, domain;
type zygote_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init zygote_exec:file { getattr open read execute };
#line 5
allow init zygote:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow zygote zygote_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow zygote init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init zygote:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init zygote:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init zygote_exec:process zygote;
#line 5

#line 5

#line 5
type zygote_tmpfs, file_type;
#line 5
type_transition zygote tmpfs:file zygote_tmpfs;
#line 5
allow zygote zygote_tmpfs:file { read write };
#line 5

#line 5

typeattribute zygote mlstrustedsubject;
# Override DAC on files and switch uid/gid.
allow zygote self:capability { dac_override setgid setuid fowner chown };
# Drop capabilities from bounding set.
allow zygote self:capability setpcap;
# Switch SELinux context to app domains.
allow zygote self:process setcurrent;
allow zygote system_server:process dyntransition;
allow zygote appdomain:process dyntransition;
# Allow zygote to read app /proc/pid dirs (b/10455872)
allow zygote appdomain:dir { getattr search };
allow zygote appdomain:file { { getattr open read ioctl lock } };
# Move children into the peer process group.
allow zygote system_server:process { getpgid setpgid };
allow zygote appdomain:process { getpgid setpgid };
# Read system data.
allow zygote system_data_file:dir { open getattr read search ioctl };
allow zygote system_data_file:file { getattr open read ioctl lock };
# Write to /data/dalvik-cache.
allow zygote dalvikcache_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow zygote dalvikcache_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
# Create symlinks in /data/dalvik-cache
allow zygote dalvikcache_data_file:lnk_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
# Write to /data/resource-cache
allow zygote resourcecache_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow zygote resourcecache_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
# For art.
allow zygote dalvikcache_data_file:file execute;
# Execute dexopt.
allow zygote system_file:file { getattr execute execute_no_trans };
allow zygote dex2oat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
# Control cgroups.
allow zygote cgroup:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow zygote self:capability sys_admin;
# Allow zygote to stat the files that it opens. The zygote must
# be able to inspect them so that it can reopen them on fork
# if necessary: b/30963384
# allow zygote pmsg_device:chr_file { getattr };
allow zygote debugfs:dir search;
allow zygote debugfs:file { getattr };

# Check validity of SELinux context before use.

#line 48
allow zygote selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 48
allow zygote kernel:security check_context;
#line 48

# Check SELinux permissions.

#line 50
allow zygote selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 50
allow zygote kernel:security compute_av;
#line 50
allow zygote self:netlink_selinux_socket *;
#line 50

# Read /seapp_contexts and /data/security/seapp_contexts

#line 52
allow zygote security_file:dir { open getattr read search ioctl };
#line 52
allow zygote security_file:file { getattr open read ioctl lock };
#line 52


# Native bridge functionality requires that zygote replaces
# /proc/cpuinfo with /system/lib/<ISA>/cpuinfo using a bind mount
allow zygote proc_cpuinfo:file mounton;

# Setting up /storage/emulated.
allow zygote rootfs:dir mounton;
allow zygote sdcard_type:dir { write search setattr create add_name mounton };
dontaudit zygote self:capability fsetid;
allow zygote tmpfs:dir { write create add_name setattr mounton search };
allow zygote tmpfs:filesystem mount;
allow zygote labeledfs:filesystem remount;

# Handle --invoke-with command when launching Zygote with a wrapper command.
allow zygote zygote_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
#line 1 "external/sepolicy/bootanim.te"
# bootanimation oneshot service
type bootanim, domain;
type bootanim_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init bootanim_exec:file { getattr open read execute };
#line 5
allow init bootanim:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow bootanim bootanim_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow bootanim init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init bootanim:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init bootanim:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init bootanim_exec:process bootanim;
#line 5

#line 5

#line 5
type bootanim_tmpfs, file_type;
#line 5
type_transition bootanim tmpfs:file bootanim_tmpfs;
#line 5
allow bootanim bootanim_tmpfs:file { read write };
#line 5

#line 5



#line 7
# Call the servicemanager and transfer references to it.
#line 7
allow bootanim servicemanager:binder { call transfer };
#line 7
# servicemanager performs getpidcon on clients.
#line 7
allow servicemanager bootanim:dir search;
#line 7
allow servicemanager bootanim:file { read open };
#line 7
allow servicemanager bootanim:process getattr;
#line 7
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 7
# all domains in domain.te.
#line 7


#line 8
# Call the server domain and optionally transfer references to it.
#line 8
allow bootanim surfaceflinger:binder { call transfer };
#line 8
# Allow the serverdomain to transfer references to the client on the reply.
#line 8
allow surfaceflinger bootanim:binder transfer;
#line 8
# Receive and use open files from the server.
#line 8
allow bootanim surfaceflinger:fd use;
#line 8


allow bootanim gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };

# /oem access
allow bootanim oemfs:dir search;
allow bootanim oemfs:file { getattr open read ioctl lock };

allow bootanim audio_device:dir { open getattr read search ioctl };
allow bootanim audio_device:chr_file { { getattr open read ioctl lock } { open append write } };

allow bootanim mediaserver:binder { transfer call };
#line 1 "external/sepolicy/keystore.te"
type keystore, domain;
type keystore_exec, exec_type, file_type;

# keystore daemon

#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init keystore_exec:file { getattr open read execute };
#line 5
allow init keystore:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow keystore keystore_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow keystore init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init keystore:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init keystore:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init keystore_exec:process keystore;
#line 5

#line 5

#line 5
type keystore_tmpfs, file_type;
#line 5
type_transition keystore tmpfs:file keystore_tmpfs;
#line 5
allow keystore keystore_tmpfs:file { read write };
#line 5

#line 5

typeattribute keystore mlstrustedsubject;

#line 7
# Call the servicemanager and transfer references to it.
#line 7
allow keystore servicemanager:binder { call transfer };
#line 7
# servicemanager performs getpidcon on clients.
#line 7
allow servicemanager keystore:dir search;
#line 7
allow servicemanager keystore:file { read open };
#line 7
allow servicemanager keystore:process getattr;
#line 7
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 7
# all domains in domain.te.
#line 7


#line 8
typeattribute keystore binderservicedomain;
#line 8

allow keystore keystore_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow keystore keystore_data_file:{ file lnk_file sock_file fifo_file } { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow keystore keystore_exec:file { getattr };
allow keystore tee_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow keystore tee:unix_stream_socket connectto;

###
### Neverallow rules
###
### Protect ourself from others
###

neverallow { domain -keystore -recovery } keystore_data_file:dir ~{ open create read getattr setattr search relabelto };
neverallow { domain -keystore -recovery } keystore_data_file:{ file lnk_file sock_file fifo_file } ~{ relabelto getattr };

neverallow { domain -keystore -init -kernel -recovery } keystore_data_file:dir *;
neverallow { domain -keystore -init -kernel -recovery } keystore_data_file:{ file lnk_file sock_file fifo_file } *;

neverallow domain keystore:process ptrace;

allow keystore keystore_service:service_manager add;

# Check SELinux permissions.

#line 32
allow keystore selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 32
allow keystore kernel:security compute_av;
#line 32
allow keystore self:netlink_selinux_socket *;
#line 32

#line 1 "external/sepolicy/app.te"
###
### Domain for all zygote spawned apps
###
### This file is the base policy for all zygote spawned apps.
### Other policy files, such as isolated_app.te, untrusted_app.te, etc
### extend from this policy. Only policies which should apply to ALL
### zygote spawned apps should be added here.
###

# Dalvik Compiler JIT Mapping.
allow appdomain self:process execmem;
allow appdomain ashmem_device:chr_file execute;

# Receive and use open file descriptors inherited from zygote.
allow appdomain zygote:fd use;

# gdbserver for ndk-gdb reads the zygote.
# valgrind needs mmap exec for zygote
allow appdomain zygote_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# gdbserver for ndk-gdb ptrace attaches to app process.
allow appdomain self:process ptrace;

# Read system properties managed by zygote.
allow appdomain zygote_tmpfs:file read;

# Notify zygote of death;
allow appdomain zygote:process sigchld;

# Notify shell and adbd of death when spawned via runas for ndk-gdb.
allow appdomain shell:process sigchld;
allow appdomain adbd:process sigchld;

# child shell or gdbserver pty access for runas.
allow appdomain devpts:chr_file { getattr read write ioctl };

# Use pipes and sockets provided by system_server via binder or local socket.
allow appdomain system_server:fifo_file { { getattr open read ioctl lock } { open append write } };
allow appdomain system_server:unix_stream_socket { read write setopt getattr getopt shutdown };
allow appdomain system_server:tcp_socket { read write getattr getopt shutdown };

# Communication with other apps via fifos
allow appdomain appdomain:fifo_file { { getattr open read ioctl lock } { open append write } };

# Communicate with surfaceflinger.
allow appdomain surfaceflinger:unix_stream_socket { read write setopt getattr getopt shutdown };

# App sandbox file accesses.
allow appdomain app_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow appdomain app_data_file:{ file lnk_file sock_file fifo_file } { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# lib subdirectory of /data/data dir is system-owned.
allow appdomain system_data_file:dir { open getattr read search ioctl };
allow appdomain system_data_file:file { execute execute_no_trans open execmod };

# Keychain and user-trusted credentials
allow appdomain keychain_data_file:dir { open getattr read search ioctl };
allow appdomain keychain_data_file:file { getattr open read ioctl lock };
allow appdomain misc_user_data_file:dir { open getattr read search ioctl };
allow appdomain misc_user_data_file:file { getattr open read ioctl lock };

# Access to OEM provided data and apps
allow appdomain oemfs:dir { open getattr read search ioctl };
allow appdomain oemfs:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Execute the shell or other system executables.
allow appdomain shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow appdomain system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Execute dex2oat when apps call dexclassloader
allow appdomain dex2oat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Read/write wallpaper file (opened by system).
allow appdomain wallpaper_file:file { getattr read write };

# Write to /data/anr/traces.txt.
allow appdomain anr_data_file:dir search;
allow appdomain anr_data_file:file { open append };

# Allow apps to send dump information to dumpstate
allow appdomain dumpstate:fd use;
allow appdomain dumpstate:unix_stream_socket { read write getopt getattr shutdown };
allow appdomain shell_data_file:file { write getattr };

# Write to /proc/net/xt_qtaguid/ctrl file.
allow appdomain qtaguid_proc:file { { getattr open read ioctl lock } { open append write } };
# Everybody can read the xt_qtaguid resource tracking misc dev.
# So allow all apps to read from /dev/xt_qtaguid.
allow appdomain qtaguid_device:chr_file { getattr open read ioctl lock };

# Grant GPU access to all processes started by Zygote.
# They need that to render the standard UI.
allow appdomain gpu_device:chr_file { { { getattr open read ioctl lock } { open append write } } execute };

# Use the Binder.

#line 96
# Call the servicemanager and transfer references to it.
#line 96
allow appdomain servicemanager:binder { call transfer };
#line 96
# servicemanager performs getpidcon on clients.
#line 96
allow servicemanager appdomain:dir search;
#line 96
allow servicemanager appdomain:file { read open };
#line 96
allow servicemanager appdomain:process getattr;
#line 96
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 96
# all domains in domain.te.
#line 96

# Perform binder IPC to binder services.

#line 98
# Call the server domain and optionally transfer references to it.
#line 98
allow appdomain binderservicedomain:binder { call transfer };
#line 98
# Allow the serverdomain to transfer references to the client on the reply.
#line 98
allow binderservicedomain appdomain:binder transfer;
#line 98
# Receive and use open files from the server.
#line 98
allow appdomain binderservicedomain:fd use;
#line 98

# Perform binder IPC to other apps.

#line 100
# Call the server domain and optionally transfer references to it.
#line 100
allow appdomain appdomain:binder { call transfer };
#line 100
# Allow the serverdomain to transfer references to the client on the reply.
#line 100
allow appdomain appdomain:binder transfer;
#line 100
# Receive and use open files from the server.
#line 100
allow appdomain appdomain:fd use;
#line 100


# Already connected, unnamed sockets being passed over some other IPC
# hence no sock_file or connectto permission. This appears to be how
# Chrome works, may need to be updated as more apps using isolated services
# are examined.
allow appdomain appdomain:unix_stream_socket { getopt getattr read write shutdown };

# Backup ability for every app. BMS opens and passes the fd
# to any app that has backup ability. Hence, no open permissions here.
allow appdomain backup_data_file:file { read write getattr };
allow appdomain cache_backup_file:file { read write getattr };
allow appdomain cache_backup_file:dir getattr;
# Backup ability using 'adb backup'
allow appdomain system_data_file:lnk_file getattr;

# Allow read/stat of /data/media files passed by Binder or local socket IPC.
allow appdomain media_rw_data_file:file { read getattr };

# Read and write /data/data/com.android.providers.telephony files passed over Binder.
allow appdomain radio_data_file:file { read write getattr };

# Read and write system app data files passed over Binder.
# Motivating case was /data/data/com.android.settings/cache/*.jpg for
# cropping or taking user photos.
allow untrusted_app system_app_data_file:file { read write getattr };

# Access SDcard via the fuse mount.
allow appdomain fuse:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow appdomain fuse:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Access OBBs (vfat images) mounted by vold (b/17633509)
allow appdomain vfat:dir { open getattr read search ioctl };
allow appdomain vfat:file { getattr open read ioctl lock };

# Allow apps to use the USB Accessory interface.
# http://developer.android.com/guide/topics/connectivity/usb/accessory.html
#
# USB devices are first opened by the system server (USBDeviceManagerService)
# and the file descriptor is passed to the right Activity via binder.
allow appdomain usb_device:chr_file { read write getattr ioctl };
allow appdomain usbaccessory_device:chr_file { read write getattr };

# For art.
allow appdomain dalvikcache_data_file:file execute;
allow appdomain dalvikcache_data_file:lnk_file { getattr open read ioctl lock };

# /data/dalvik-cache/profiles
allow appdomain dalvikcache_profiles_data_file:dir { search getattr };
allow appdomain dalvikcache_profiles_data_file:file { { getattr open read ioctl lock } { open append write } };

# Allow any app to read shared RELRO files.
allow appdomain shared_relro_file:dir search;
allow appdomain shared_relro_file:file { getattr open read ioctl lock };

# Allow apps to read/execute installed binaries
allow appdomain apk_data_file:dir { open getattr read search ioctl };
allow appdomain apk_data_file:file { { { getattr open read ioctl lock } { getattr execute execute_no_trans } } execmod };

# /data/resource-cache
allow appdomain resourcecache_data_file:file { getattr open read ioctl lock };
allow appdomain resourcecache_data_file:dir { open getattr read search ioctl };

###
### CTS-specific rules
###

# For cts/tools/device-setup/TestDeviceSetup/src/android/tests/getinfo/RootProcessScanner.java.
# Reads /proc/pid/status and statm entries to check that
# no unexpected root processes are running.
# Also for cts/tests/tests/security/src/android/security/cts/VoldExploitTest.java
# Reads /proc/pid/cmdline of vold.
allow appdomain domain:dir { open read search getattr };
allow appdomain domain:{ file lnk_file } { open read getattr };

# For cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java.
# testRunAsHasCorrectCapabilities
allow appdomain runas_exec:file getattr;
# Others are either allowed elsewhere or not desired.

# For cts/tests/tests/security/src/android/security/cts/SELinuxTest.java
# Check SELinux policy and contexts.

#line 182
allow appdomain selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 182
allow appdomain kernel:security compute_av;
#line 182
allow appdomain self:netlink_selinux_socket *;
#line 182


#line 183
allow appdomain selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 183
allow appdomain kernel:security check_context;
#line 183

# Validate that each process is running in the correct security context.
allow appdomain domain:process getattr;

# logd access

#line 188

#line 188
allow appdomain logdr_socket:sock_file write;
#line 188
allow appdomain logd:unix_stream_socket connectto;
#line 188

#line 188


#line 189
# Group AID_LOG checked by filesystem & logd
#line 189
# to permit control commands
#line 189

#line 189
allow appdomain logd_socket:sock_file write;
#line 189
allow appdomain logd:unix_stream_socket connectto;
#line 189

#line 189

# application inherit logd write socket (urge is to deprecate this long term)
allow appdomain zygote:unix_dgram_socket write;

allow appdomain keystore:keystore_key { test get insert delete exist saw sign verify };


#line 195
  allow keystore appdomain:dir search;
#line 195
  allow keystore appdomain:file { read open };
#line 195
  allow keystore appdomain:process getattr;
#line 195
  
#line 195
# Call the server domain and optionally transfer references to it.
#line 195
allow appdomain keystore:binder { call transfer };
#line 195
# Allow the serverdomain to transfer references to the client on the reply.
#line 195
allow keystore appdomain:binder transfer;
#line 195
# Receive and use open files from the server.
#line 195
allow appdomain keystore:fd use;
#line 195

#line 195


###
### Neverallow rules
###
### These are things that Android apps should NEVER be able to do
###

# Superuser capabilities.
# bluetooth requires net_admin and wake_alarm.
neverallow { appdomain -bluetooth } self:capability *;
neverallow { appdomain -bluetooth } self:capability2 *;

# Block device access.
neverallow appdomain dev_type:blk_file { read write };

# Access to any of the following character devices.
neverallow appdomain {
    audio_device
    camera_device
    dm_device
    radio_device
    gps_device
    rpmsg_device
}:chr_file { read write };

# Note: Try expanding list of app domains in the future.
neverallow { untrusted_app isolated_app shell } graphics_device:chr_file { read write };

neverallow { appdomain -nfc } nfc_device:chr_file
    { read write };
neverallow { appdomain -bluetooth } hci_attach_dev:chr_file
    { read write };
neverallow appdomain tee_device:chr_file { read write };

# Privileged netlink socket interfaces.
neverallow appdomain
    domain:{
        netlink_firewall_socket
        netlink_tcpdiag_socket
        netlink_nflog_socket
        netlink_xfrm_socket
        netlink_audit_socket
        netlink_ip6fw_socket
        netlink_dnrt_socket
    } *;

# These messages are broadcast messages from the kernel to userspace.
# Do not allow the writing of netlink messages, which has been a source
# of rooting vulns in the past.
neverallow appdomain domain:netlink_kobject_uevent_socket { write append };

# Sockets under /dev/socket that are not specifically typed.
neverallow appdomain socket_device:sock_file write;

# Unix domain sockets.
neverallow appdomain adbd_socket:sock_file write;
neverallow appdomain installd_socket:sock_file write;
neverallow { appdomain -bluetooth -radio -shell -system_app -nfc }
    property_socket:sock_file write;
neverallow { appdomain -radio } rild_socket:sock_file write;
neverallow appdomain vold_socket:sock_file write;
neverallow appdomain zygote_socket:sock_file write;

# ptrace access to non-app domains.
neverallow appdomain { domain -appdomain }:process ptrace;

# Write access to /proc/pid entries for any non-app domain.
neverallow appdomain { domain -appdomain }:file write;

# signal access to non-app domains.
# sigchld allowed for parent death notification.
# signull allowed for kill(pid, 0) existence test.
# All others prohibited.
neverallow appdomain { domain -appdomain }:process
    { sigkill sigstop signal };

# Transition to a non-app domain.
# Exception for the shell domain, can transition to runas, etc.
neverallow { appdomain -shell } { domain -appdomain }:process
    { transition dyntransition };

# Write to rootfs.
neverallow appdomain rootfs:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to /system.
neverallow appdomain system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to entrypoint executables.
neverallow appdomain exec_type:file
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to system-owned parts of /data.
# This is the default type for anything under /data not otherwise
# specified in file_contexts.  Define a different type for portions
# that should be writable by apps.
# Exception for system_app for Settings.
neverallow { appdomain -system_app }
    system_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to various other parts of /data.
neverallow appdomain drm_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -system_app }
    gps_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_tmp_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_private_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_private_tmp_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -shell }
    shell_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -bluetooth }
    bluetooth_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    keystore_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    systemkeys_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    wifi_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    dhcp_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Access to factory files.
neverallow appdomain efs_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
neverallow { appdomain -shell } efs_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } read;

# Write to various pseudo file systems.
neverallow { appdomain -bluetooth -nfc }
    sysfs:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
neverallow appdomain
    proc:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Access to syslog(2) or /proc/kmsg.
neverallow { appdomain -system_app }
    kernel:system { syslog_mod syslog_console };
neverallow { appdomain -system_app -shell }
    kernel:system syslog_read;

# Ability to perform any filesystem operation other than statfs(2).
# i.e. no mount(2), unmount(2), etc.
neverallow appdomain fs_type:filesystem ~getattr;

# Ability to set system properties.
neverallow { appdomain -system_app -radio -shell -bluetooth -nfc }
    property_type:property_service set;
#line 1 "external/sepolicy/netd.te"
# network manager
type netd, domain;
type netd_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init netd_exec:file { getattr open read execute };
#line 5
allow init netd:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow netd netd_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow netd init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init netd:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init netd:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init netd_exec:process netd;
#line 5

#line 5

#line 5
type netd_tmpfs, file_type;
#line 5
type_transition netd tmpfs:file netd_tmpfs;
#line 5
allow netd netd_tmpfs:file { read write };
#line 5

#line 5


#line 6
typeattribute netd netdomain;
#line 6


allow netd self:capability { net_admin net_raw kill };
# Note: fsetid is deliberately not included above. fsetid checks are
# triggered by chmod on a directory or file owned by a group other
# than one of the groups assigned to the current process to see if
# the setgid bit should be cleared, regardless of whether the setgid
# bit was even set.  We do not appear to truly need this capability
# for netd to operate.  Uncomment the dontaudit rule below after
# sufficient testing of the fsetid removal.
# dontaudit netd self:capability fsetid;

allow netd self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd self:netlink_route_socket nlmsg_write;
allow netd self:netlink_nflog_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow netd system_file:file { getattr execute execute_no_trans };
allow netd devpts:chr_file { { getattr open read ioctl lock } { open append write } };

# For /proc/sys/net/ipv[46]/route/flush.
allow netd proc_net:file write;

# For /sys/modules/bcmdhd/parameters/firmware_path
# XXX Split into its own type.
allow netd sysfs:file write;

# Set dhcp lease for PAN connection

#line 33
allow netd property_socket:sock_file write;
#line 33
allow netd init:unix_stream_socket connectto;
#line 33

allow netd dhcp_prop:property_service set;
allow netd system_prop:property_service set;
auditallow netd system_prop:property_service set;

# Connect to PAN

#line 39
# Allow the necessary permissions.
#line 39

#line 39
# Old domain may exec the file and transition to the new domain.
#line 39
allow netd dhcp_exec:file { getattr open read execute };
#line 39
allow netd dhcp:process transition;
#line 39
# New domain is entered by executing the file.
#line 39
allow dhcp dhcp_exec:file { entrypoint open read execute getattr };
#line 39
# New domain can send SIGCHLD to its caller.
#line 39
allow dhcp netd:process sigchld;
#line 39
# Enable AT_SECURE, i.e. libc secure mode.
#line 39
dontaudit netd dhcp:process noatsecure;
#line 39
# XXX dontaudit candidate but requires further study.
#line 39
allow netd dhcp:process { siginh rlimitinh };
#line 39

#line 39
# Make the transition occur by default.
#line 39
type_transition netd dhcp_exec:process dhcp;
#line 39

allow netd dhcp:process signal;

# Needed to update /data/misc/wifi/hostapd.conf
# TODO: See what we can do to reduce the need for
# these capabilities
allow netd self:capability { dac_override chown fowner };
allow netd wifi_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow netd wifi_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow netd wifi_data_file:sock_file { create setattr unlink write };

# Allow netd to chmod dir /data/misc/dhcp
allow netd dhcp_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };

# Needed to update /data/misc/net/rt_tables
allow netd net_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow netd net_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };

# Allow netd to spawn hostapd in it's own domain

#line 58
# Allow the necessary permissions.
#line 58

#line 58
# Old domain may exec the file and transition to the new domain.
#line 58
allow netd hostapd_exec:file { getattr open read execute };
#line 58
allow netd hostapd:process transition;
#line 58
# New domain is entered by executing the file.
#line 58
allow hostapd hostapd_exec:file { entrypoint open read execute getattr };
#line 58
# New domain can send SIGCHLD to its caller.
#line 58
allow hostapd netd:process sigchld;
#line 58
# Enable AT_SECURE, i.e. libc secure mode.
#line 58
dontaudit netd hostapd:process noatsecure;
#line 58
# XXX dontaudit candidate but requires further study.
#line 58
allow netd hostapd:process { siginh rlimitinh };
#line 58

#line 58
# Make the transition occur by default.
#line 58
type_transition netd hostapd_exec:process hostapd;
#line 58

allow netd hostapd:process signal;

# Allow netd to spawn dnsmasq in it's own domain

#line 62
# Allow the necessary permissions.
#line 62

#line 62
# Old domain may exec the file and transition to the new domain.
#line 62
allow netd dnsmasq_exec:file { getattr open read execute };
#line 62
allow netd dnsmasq:process transition;
#line 62
# New domain is entered by executing the file.
#line 62
allow dnsmasq dnsmasq_exec:file { entrypoint open read execute getattr };
#line 62
# New domain can send SIGCHLD to its caller.
#line 62
allow dnsmasq netd:process sigchld;
#line 62
# Enable AT_SECURE, i.e. libc secure mode.
#line 62
dontaudit netd dnsmasq:process noatsecure;
#line 62
# XXX dontaudit candidate but requires further study.
#line 62
allow netd dnsmasq:process { siginh rlimitinh };
#line 62

#line 62
# Make the transition occur by default.
#line 62
type_transition netd dnsmasq_exec:process dnsmasq;
#line 62

allow netd dnsmasq:process signal;

# Allow netd to start clatd in its own domain

#line 66
# Allow the necessary permissions.
#line 66

#line 66
# Old domain may exec the file and transition to the new domain.
#line 66
allow netd clatd_exec:file { getattr open read execute };
#line 66
allow netd clatd:process transition;
#line 66
# New domain is entered by executing the file.
#line 66
allow clatd clatd_exec:file { entrypoint open read execute getattr };
#line 66
# New domain can send SIGCHLD to its caller.
#line 66
allow clatd netd:process sigchld;
#line 66
# Enable AT_SECURE, i.e. libc secure mode.
#line 66
dontaudit netd clatd:process noatsecure;
#line 66
# XXX dontaudit candidate but requires further study.
#line 66
allow netd clatd:process { siginh rlimitinh };
#line 66

#line 66
# Make the transition occur by default.
#line 66
type_transition netd clatd_exec:process clatd;
#line 66

allow netd clatd:process signal;

allow netd ctl_mdnsd_prop:property_service set;

# Allow netd to operate on sockets that are passed to it.
allow netd netdomain:{tcp_socket udp_socket rawip_socket dccp_socket tun_socket} {read write getattr setattr getopt setopt};
allow netd netdomain:fd use;

###
### Neverallow rules
###
### netd should NEVER do any of this

# Block device access.
neverallow netd dev_type:blk_file { read write };

# ptrace any other app
neverallow netd { domain }:process ptrace;

# Write to /system.
neverallow netd system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Write to files in /data/data or system files on /data
neverallow netd { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
#line 1 "external/sepolicy/ppp.te"
# Point to Point Protocol daemon
type ppp, domain;
type ppp_device, dev_type;
type ppp_exec, exec_type, file_type;

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow mtp ppp_exec:file { getattr open read execute };
#line 5
allow mtp ppp:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow ppp ppp_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow ppp mtp:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit mtp ppp:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow mtp ppp:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition mtp ppp_exec:process ppp;
#line 5



#line 7
typeattribute ppp netdomain;
#line 7


allow ppp mtp:socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow ppp mtp:unix_dgram_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow ppp ppp_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow ppp self:capability net_admin;
allow ppp system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow ppp vpn_data_file:dir { open search write add_name remove_name };
allow ppp vpn_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow ppp mtp:fd use;
#line 1 "external/sepolicy/dex2oat.te"
# dex2oat
type dex2oat, domain;
type dex2oat_exec, exec_type, file_type;

allow dex2oat dalvikcache_data_file:file write;
# Read symlinks in /data/dalvik-cache
allow dex2oat dalvikcache_data_file:lnk_file read;
allow dex2oat installd:fd use;

# Read already open asec_apk_file file descriptors passed by installd.
# Also allow reading unlabeled files, to allow for upgrading forward
# locked APKs.
allow dex2oat asec_apk_file:file read;
allow dex2oat unlabeled:file read;
allow dex2oat oemfs:file read;
#line 1 "external/sepolicy/binderservicedomain.te"
# Rules common to all binder service domains

# Allow dumpstate to collect information from binder services
allow binderservicedomain dumpstate:fd use;
allow binderservicedomain dumpstate:unix_stream_socket { read write getopt getattr };
allow binderservicedomain shell_data_file:file { getattr write };

# Allow dumpsys to work from adb shell or the serial console
allow binderservicedomain devpts:chr_file { { getattr open read ioctl lock } { open append write } };
allow binderservicedomain console_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Receive and write to a pipe received over Binder from an app.
allow binderservicedomain appdomain:fd use;
allow binderservicedomain appdomain:fifo_file write;

allow binderservicedomain keystore:keystore_key { test get insert delete exist saw sign verify };


#line 18
  allow keystore binderservicedomain:dir search;
#line 18
  allow keystore binderservicedomain:file { read open };
#line 18
  allow keystore binderservicedomain:process getattr;
#line 18
  
#line 18
# Call the server domain and optionally transfer references to it.
#line 18
allow binderservicedomain keystore:binder { call transfer };
#line 18
# Allow the serverdomain to transfer references to the client on the reply.
#line 18
allow keystore binderservicedomain:binder transfer;
#line 18
# Receive and use open files from the server.
#line 18
allow binderservicedomain keystore:fd use;
#line 18

#line 18

#line 1 "external/sepolicy/shell.te"
# Domain for shell processes spawned by ADB or console service.
type shell, domain, mlstrustedsubject;
type shell_exec, exec_type, file_type;

# Create and use network sockets.

#line 6
typeattribute shell netdomain;
#line 6


# Run app_process.
# XXX Transition into its own domain?

#line 10
typeattribute shell appdomain;
#line 10
# Label ashmem objects with our own unique type.
#line 10

#line 10
type shell_tmpfs, file_type;
#line 10
type_transition shell tmpfs:file shell_tmpfs;
#line 10
allow shell shell_tmpfs:file { read write };
#line 10

#line 10
# Map with PROT_EXEC.
#line 10
allow shell shell_tmpfs:file execute;
#line 10


# logd access

#line 13

#line 13
allow shell logdr_socket:sock_file write;
#line 13
allow shell logd:unix_stream_socket connectto;
#line 13

#line 13


#line 14
# Group AID_LOG checked by filesystem & logd
#line 14
# to permit control commands
#line 14

#line 14
allow shell logd_socket:sock_file write;
#line 14
allow shell logd:unix_stream_socket connectto;
#line 14

#line 14


# read files in /data/anr
allow shell anr_data_file:dir { open getattr read search ioctl };
allow shell anr_data_file:file { getattr open read ioctl lock };

# Access /data/local/tmp.
allow shell shell_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow shell shell_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow shell shell_data_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow shell shell_data_file:lnk_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# adb bugreport

#line 27
allow shell dumpstate_socket:sock_file write;
#line 27
allow shell dumpstate:unix_stream_socket connectto;
#line 27


allow shell devpts:chr_file { { getattr open read ioctl lock } { open append write } };
allow shell tty_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow shell console_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow shell input_device:dir { open getattr read search ioctl };
allow shell input_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow shell system_file:file { getattr execute execute_no_trans };
allow shell shell_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
allow shell zygote_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };


#line 38
allow shell apk_data_file:dir { open getattr read search ioctl };
#line 38
allow shell apk_data_file:{ file lnk_file } { getattr open read ioctl lock };
#line 38


# Set properties.

#line 41
allow shell property_socket:sock_file write;
#line 41
allow shell init:unix_stream_socket connectto;
#line 41

allow shell shell_prop:property_service set;
allow shell ctl_dumpstate_prop:property_service set;
allow shell debug_prop:property_service set;
allow shell powerctl_prop:property_service set;

# systrace support - allow atrace to run
# debugfs doesn't support labeling individual files, so we have
# to grant read access to all of /sys/kernel/debug.
# Directory read access and file write access is already granted
# in domain.te.
allow shell debugfs:file { getattr open read ioctl lock };

# allow shell to run dmesg
allow shell kernel:system syslog_read;
#line 1 "external/sepolicy/installd.te"
# installer daemon
type installd, domain;
type installd_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init installd_exec:file { getattr open read execute };
#line 5
allow init installd:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow installd installd_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow installd init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init installd:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init installd:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init installd_exec:process installd;
#line 5

#line 5

#line 5
type installd_tmpfs, file_type;
#line 5
type_transition installd tmpfs:file installd_tmpfs;
#line 5
allow installd installd_tmpfs:file { read write };
#line 5

#line 5

typeattribute installd mlstrustedsubject;
allow installd self:capability { chown dac_override fowner fsetid setgid setuid };
allow installd apk_data_file:file rename;
allow installd apk_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow installd apk_data_file:lnk_file { create read unlink };
allow installd asec_apk_file:file { getattr open read ioctl lock };
allow installd apk_tmp_file:file { getattr open read ioctl lock };
allow installd oemfs:dir { open getattr read search ioctl };
allow installd oemfs:file { getattr open read ioctl lock };
allow installd system_file:file { getattr execute execute_no_trans };
allow installd cgroup:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
# Check validity of SELinux context before use.

#line 18
allow installd selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 18
allow installd kernel:security check_context;
#line 18

# Read /seapp_contexts and /data/security/seapp_contexts

#line 20
allow installd security_file:dir { open getattr read search ioctl };
#line 20
allow installd security_file:file { getattr open read ioctl lock };
#line 20


# Search /data/app-asec and stat files in it.
allow installd asec_image_file:dir search;
allow installd asec_image_file:file getattr;

# Create /data/user and /data/user/0 if necessary.
# Also required to initially create /data/data subdirectories
# and lib symlinks before the setfilecon call.  May want to
# move symlink creation after setfilecon in installd.
allow installd system_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow installd system_data_file:lnk_file { create setattr unlink };

# Upgrade /data/media for multi-user if necessary.
allow installd media_rw_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow installd media_rw_data_file:file { getattr unlink };
# restorecon new /data/media directory.
allow installd system_data_file:dir relabelfrom;
allow installd media_rw_data_file:dir relabelto;

# Upgrade /data/misc/keychain for multi-user if necessary.
allow installd misc_user_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow installd misc_user_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow installd keychain_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow installd keychain_data_file:file {{ getattr open read ioctl lock } unlink};

# Create /data/.layout_version.* file
type_transition installd system_data_file:file install_data_file;
allow installd install_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Create files under /data/dalvik-cache.
allow installd dalvikcache_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow installd dalvikcache_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Create /data/dalvik-cache/profiles.
allow installd dalvikcache_profiles_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow installd dalvikcache_profiles_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Create files under /data/resource-cache.
allow installd resourcecache_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow installd resourcecache_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Run dex2oat in its own sandbox.

#line 63
# Allow the necessary permissions.
#line 63

#line 63
# Old domain may exec the file and transition to the new domain.
#line 63
allow installd dex2oat_exec:file { getattr open read execute };
#line 63
allow installd dex2oat:process transition;
#line 63
# New domain is entered by executing the file.
#line 63
allow dex2oat dex2oat_exec:file { entrypoint open read execute getattr };
#line 63
# New domain can send SIGCHLD to its caller.
#line 63
allow dex2oat installd:process sigchld;
#line 63
# Enable AT_SECURE, i.e. libc secure mode.
#line 63
dontaudit installd dex2oat:process noatsecure;
#line 63
# XXX dontaudit candidate but requires further study.
#line 63
allow installd dex2oat:process { siginh rlimitinh };
#line 63

#line 63
# Make the transition occur by default.
#line 63
type_transition installd dex2oat_exec:process dex2oat;
#line 63

# dex2oat needs LD_PRELOAD, passed down from init
# https://android-review.googlesource.com/94851
allow installd dex2oat:process noatsecure;

# Upgrade from unlabeled userdata.
# Just need enough to remove and/or relabel it.
allow installd unlabeled:dir { getattr search relabelfrom { { open getattr read search ioctl } { open search write add_name remove_name } } rmdir };
allow installd unlabeled:{ file lnk_file sock_file fifo_file } { getattr relabelfrom rename unlink setattr };
# Read pkg.apk file for input during dexopt.
allow installd unlabeled:file { getattr open read ioctl lock };

# Upgrade from before system_app_data_file was used for system UID apps.
# Just need enough to relabel it and to unlink removed package files.
# Directory access covered by earlier rule above.
allow installd system_data_file:{ file lnk_file sock_file fifo_file } { getattr relabelfrom unlink };

# Manage /data/data subdirectories, including initially labeling them
# upon creation via setfilecon or running restorecon_recursive,
# setting owner/mode, creating symlinks within them, and deleting them
# upon package uninstall.
# Types extracted from seapp_contexts type= fields.
allow installd { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:dir { { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } } relabelfrom relabelto };
allow installd { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:lnk_file { create setattr getattr unlink rename relabelfrom relabelto };
allow installd { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:{ file sock_file fifo_file } { getattr unlink rename relabelfrom relabelto setattr };
#line 1 "external/sepolicy/servicemanager.te"
# servicemanager - the Binder context manager
type servicemanager, domain;
type servicemanager_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init servicemanager_exec:file { getattr open read execute };
#line 5
allow init servicemanager:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow servicemanager servicemanager_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow servicemanager init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init servicemanager:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init servicemanager:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init servicemanager_exec:process servicemanager;
#line 5

#line 5

#line 5
type servicemanager_tmpfs, file_type;
#line 5
type_transition servicemanager tmpfs:file servicemanager_tmpfs;
#line 5
allow servicemanager servicemanager_tmpfs:file { read write };
#line 5

#line 5


# Note that we do not use the binder_* macros here.
# servicemanager is unique in that it only provides
# name service (aka context manager) for Binder.
# As such, it only ever receives and transfers other references
# created by other domains.  It never passes its own references
# or initiates a Binder IPC.
allow servicemanager self:binder set_context_mgr;
allow servicemanager domain:binder transfer;

# Check SELinux permissions.

#line 17
allow servicemanager selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 17
allow servicemanager kernel:security compute_av;
#line 17
allow servicemanager self:netlink_selinux_socket *;
#line 17

#line 1 "external/sepolicy/su.te"
# File types must be defined for file_contexts.
type su_exec, exec_type, file_type;


#line 4
  # Domain used for su processes, as well as for adbd and adb shell
#line 4
  # after performing an adb root command.  The domain definition is
#line 4
  # wrapped to ensure that it does not exist at all on -user builds.
#line 4
  type su, domain;
#line 4
  
#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow shell su_exec:file { getattr open read execute };
#line 4
allow shell su:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow su su_exec:file { entrypoint open read execute getattr };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4
allow su shell:process sigchld;
#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit shell su:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow shell su:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition shell su_exec:process su;
#line 4

#line 4

#line 4
  # Allow dumpstate to call su on userdebug / eng builds to collect
#line 4
  # additional information.
#line 4
  
#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow dumpstate su_exec:file { getattr open read execute };
#line 4
allow dumpstate su:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow su su_exec:file { entrypoint open read execute getattr };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4
allow su dumpstate:process sigchld;
#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit dumpstate su:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow dumpstate su:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition dumpstate su_exec:process su;
#line 4

#line 4

#line 4
  # su is also permissive to permit setenforce.
#line 4
  permissive su;
#line 4

#line 4
  # Add su to various domains
#line 4
  
#line 4
typeattribute su netdomain;
#line 4

#line 4
  
#line 4
typeattribute su appdomain;
#line 4
# Label ashmem objects with our own unique type.
#line 4

#line 4
type su_tmpfs, file_type;
#line 4
type_transition su tmpfs:file su_tmpfs;
#line 4
allow su su_tmpfs:file { read write };
#line 4

#line 4
# Map with PROT_EXEC.
#line 4
allow su su_tmpfs:file execute;
#line 4

#line 4

#line 4
  dontaudit su self:{ capability capability2 } *;
#line 4
  dontaudit su kernel:security *;
#line 4
  dontaudit su kernel:system *;
#line 4
  dontaudit su self:memprotect *;
#line 4
  dontaudit su domain:process *;
#line 4
  dontaudit su domain:fd *;
#line 4
  dontaudit su domain:dir *;
#line 4
  dontaudit su domain:lnk_file *;
#line 4
  dontaudit su domain:{ fifo_file file } *;
#line 4
  dontaudit su domain:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket } *;
#line 4
  dontaudit su domain:{ sem msgq shm ipc } *;
#line 4
  dontaudit su domain:key *;
#line 4
  dontaudit su fs_type:filesystem *;
#line 4
  dontaudit su {fs_type dev_type file_type}:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } *;
#line 4
  dontaudit su node_type:node *;
#line 4
  dontaudit su node_type:{ tcp_socket udp_socket rawip_socket } *;
#line 4
  dontaudit su netif_type:netif *;
#line 4
  dontaudit su port_type:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket } *;
#line 4
  dontaudit su port_type:{ tcp_socket dccp_socket } *;
#line 4
  dontaudit su domain:peer *;
#line 4
  dontaudit su domain:binder *;
#line 4
  dontaudit su property_type:property_service *;
#line 44

#line 1 "external/sepolicy/mtp.te"
# vpn tunneling protocol manager
type mtp, domain;
type mtp_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init mtp_exec:file { getattr open read execute };
#line 5
allow init mtp:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow mtp mtp_exec:file { entrypoint open read execute getattr };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow mtp init:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init mtp:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init mtp:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init mtp_exec:process mtp;
#line 5

#line 5

#line 5
type mtp_tmpfs, file_type;
#line 5
type_transition mtp tmpfs:file mtp_tmpfs;
#line 5
allow mtp mtp_tmpfs:file { read write };
#line 5

#line 5


#line 6
typeattribute mtp netdomain;
#line 6


# pptp policy
allow mtp self:socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow mtp self:capability net_raw;
allow mtp ppp:process signal;
allow mtp vpn_data_file:dir search;
#line 1 "external/sepolicy/device.te"
# Device types
type device, dev_type, fs_type;
type alarm_device, dev_type, mlstrustedobject;
type adb_device, dev_type;
type ashmem_device, dev_type, mlstrustedobject;
type audio_device, dev_type;
type binder_device, dev_type, mlstrustedobject;
type block_device, dev_type;
type camera_device, dev_type;
type dm_device, dev_type;
type loop_device, dev_type;
type radio_device, dev_type;
type ram_device, dev_type;
type console_device, dev_type;
type cpuctl_device, dev_type;
type fscklogs, dev_type;
type full_device, dev_type;
# GPU (used by most UI apps)
type gpu_device, dev_type, mlstrustedobject;
type graphics_device, dev_type;
type hw_random_device, dev_type;
type input_device, dev_type;
type kmem_device, dev_type;
type log_device, dev_type, mlstrustedobject;
type mtd_device, dev_type;
type mtp_device, dev_type, mlstrustedobject;
type nfc_device, dev_type;
type ptmx_device, dev_type, mlstrustedobject;
type kmsg_device, dev_type;
type null_device, dev_type, mlstrustedobject;
type random_device, dev_type;
type sensors_device, dev_type;
type serial_device, dev_type;
type socket_device, dev_type;
type owntty_device, dev_type, mlstrustedobject;
type tty_device, dev_type;
type urandom_device, dev_type;
type video_device, dev_type;
type vcs_device, dev_type;
type zero_device, dev_type;
type fuse_device, dev_type;
type iio_device, dev_type;
type ion_device, dev_type, mlstrustedobject;
type gps_device, dev_type;
type qtaguid_device, dev_type;
type watchdog_device, dev_type;
type uhid_device, dev_type;
type uio_device, dev_type;
type tun_device, dev_type, mlstrustedobject;
type usbaccessory_device, dev_type;
type usb_device, dev_type;
type klog_device, dev_type;
type properties_device, dev_type;

# All devices have a uart for the hci
# attach service. The uart dev node
# varies per device. This type
# is used in per device policy
type hci_attach_dev, dev_type;

# All devices have a rpmsg device for
# achieving remoteproc and rpmsg modules
type rpmsg_device, dev_type;

# Partition layout block device
type root_block_device, dev_type;

# factory reset protection block device
type frp_block_device, dev_type;

# Userdata block device mounted on /data.
type userdata_block_device, dev_type;

# Cache block device mounted on /cache.
type cache_block_device, dev_type;
#line 1 "external/sepolicy/adbd.te"
# adbd seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type adbd, domain;


#line 5
  allow adbd self:process setcurrent;
#line 5
  allow adbd su:process dyntransition;
#line 8



#line 10
# Allow the necessary permissions.
#line 10

#line 10
# Old domain may exec the file and transition to the new domain.
#line 10
allow adbd shell_exec:file { getattr open read execute };
#line 10
allow adbd shell:process transition;
#line 10
# New domain is entered by executing the file.
#line 10
allow shell shell_exec:file { entrypoint open read execute getattr };
#line 10
# New domain can send SIGCHLD to its caller.
#line 10
allow shell adbd:process sigchld;
#line 10
# Enable AT_SECURE, i.e. libc secure mode.
#line 10
dontaudit adbd shell:process noatsecure;
#line 10
# XXX dontaudit candidate but requires further study.
#line 10
allow adbd shell:process { siginh rlimitinh };
#line 10

#line 10
# Make the transition occur by default.
#line 10
type_transition adbd shell_exec:process shell;
#line 10


# Do not sanitize the environment or open fds of the shell.
allow adbd shell:process noatsecure;

# Set UID and GID to shell.  Set supplementary groups.
allow adbd self:capability { setuid setgid };

# Drop capabilities from bounding set on user builds.
allow adbd self:capability setpcap;

# Create and use network sockets.

#line 22
typeattribute adbd netdomain;
#line 22


# Access /dev/android_adb or /dev/usb-ffs/adb/ep0
allow adbd adb_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow adbd functionfs:dir search;
allow adbd functionfs:file { { getattr open read ioctl lock } { open append write } };

# Use a pseudo tty.
allow adbd devpts:chr_file { { getattr open read ioctl lock } { open append write } };

# adb push/pull /data/local/tmp.
allow adbd shell_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow adbd shell_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# adb push/pull sdcard.
allow adbd sdcard_type:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow adbd sdcard_type:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# adb pull /data/anr/traces.txt
allow adbd anr_data_file:dir { open getattr read search ioctl };
allow adbd anr_data_file:file { getattr open read ioctl lock };

# Set service.adb.*, sys.powerctl properties.

#line 45
allow adbd property_socket:sock_file write;
#line 45
allow adbd init:unix_stream_socket connectto;
#line 45

allow adbd shell_prop:property_service set;
allow adbd powerctl_prop:property_service set;

# Run /system/bin/bu
allow adbd system_file:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };

# Perform binder IPC to surfaceflinger (screencap)
# XXX Run screencap in a separate domain?

#line 54
# Call the servicemanager and transfer references to it.
#line 54
allow adbd servicemanager:binder { call transfer };
#line 54
# servicemanager performs getpidcon on clients.
#line 54
allow servicemanager adbd:dir search;
#line 54
allow servicemanager adbd:file { read open };
#line 54
allow servicemanager adbd:process getattr;
#line 54
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 54
# all domains in domain.te.
#line 54


#line 55
# Call the server domain and optionally transfer references to it.
#line 55
allow adbd surfaceflinger:binder { call transfer };
#line 55
# Allow the serverdomain to transfer references to the client on the reply.
#line 55
allow surfaceflinger adbd:binder transfer;
#line 55
# Receive and use open files from the server.
#line 55
allow adbd surfaceflinger:fd use;
#line 55

# b/13188914
allow adbd gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Read /data/misc/adb/adb_keys.
allow adbd adb_keys_file:dir search;
allow adbd adb_keys_file:file { getattr open read ioctl lock };


#line 63
  # Write debugging information to /data/adb
#line 63
  # when persist.adb.trace_mask is set
#line 63
  # https://code.google.com/p/android/issues/detail?id=72895
#line 63
  allow adbd adb_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
#line 63
  allow adbd adb_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
#line 69


# ndk-gdb invokes adb forward to forward the gdbserver socket.
allow adbd app_data_file:dir search;
allow adbd app_data_file:sock_file write;
allow adbd appdomain:unix_stream_socket connectto;

# b/18078338 - allow read access to executable types on /system
# to assist with debugging OTA issues.
allow adbd exec_type:file { getattr open read ioctl lock };

# ndk-gdb invokes adb pull of app_process, linker, and libc.so.
allow adbd zygote_exec:file { getattr open read ioctl lock };
allow adbd system_file:file { getattr open read ioctl lock };

allow adbd kernel:security read_policy;
#line 1 "external/sepolicy/hci_attach.te"
type hci_attach, domain;
type hci_attach_exec, exec_type, file_type;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init hci_attach_exec:file { getattr open read execute };
#line 4
allow init hci_attach:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow hci_attach hci_attach_exec:file { entrypoint open read execute getattr };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4
allow hci_attach init:process sigchld;
#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init hci_attach:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init hci_attach:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init hci_attach_exec:process hci_attach;
#line 4

#line 4

#line 4
type hci_attach_tmpfs, file_type;
#line 4
type_transition hci_attach tmpfs:file hci_attach_tmpfs;
#line 4
allow hci_attach hci_attach_tmpfs:file { read write };
#line 4

#line 4


allow hci_attach kernel:system module_request;
allow hci_attach hci_attach_dev:chr_file { { getattr open read ioctl lock } { open append write } };
allow hci_attach bluetooth_efs_file:dir { open getattr read search ioctl };
allow hci_attach bluetooth_efs_file:file { getattr open read ioctl lock };
#line 1 "external/sepolicy/system_server.te"
#
# System Server aka system_server spawned by zygote.
# Most of the framework services run in this process.
#
type system_server, domain, mlstrustedsubject;

# Define a type for tmpfs-backed ashmem regions.

#line 8
type system_server_tmpfs, file_type;
#line 8
type_transition system_server tmpfs:file system_server_tmpfs;
#line 8
allow system_server system_server_tmpfs:file { read write };
#line 8


# Dalvik Compiler JIT Mapping.
allow system_server self:process execmem;
allow system_server ashmem_device:chr_file execute;
allow system_server system_server_tmpfs:file execute;

# For art.
allow system_server dalvikcache_data_file:file execute;

# /data/resource-cache
allow system_server resourcecache_data_file:file { getattr open read ioctl lock };
allow system_server resourcecache_data_file:dir { open getattr read search ioctl };

# ptrace to processes in the same domain for debugging crashes.
allow system_server self:process ptrace;

# Child of the zygote.
allow system_server zygote:fd use;
allow system_server zygote:process sigchld;
allow system_server zygote_tmpfs:file read;

# May kill zygote on crashes.
allow system_server zygote:process sigkill;

# Read /system/bin/app_process.
allow system_server zygote_exec:file { getattr open read ioctl lock };

# Needed to close the zygote socket, which involves getopt / getattr
allow system_server zygote:unix_stream_socket { getopt getattr };

# system server gets network and bluetooth permissions.

#line 40
typeattribute system_server netdomain;
#line 40


#line 41
typeattribute system_server bluetoothdomain;
#line 41


# These are the capabilities assigned by the zygote to the
# system server.
allow system_server self:capability {
    kill
    net_admin
    net_bind_service
    net_broadcast
    net_raw
    sys_boot
    sys_module
    sys_nice
    sys_resource
    sys_time
    sys_tty_config
};


#line 59
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 59
allow system_server sysfs_wake_lock:file { { getattr open read ioctl lock } { open append write } };
#line 59
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 59
allow system_server self:capability2 block_suspend;
#line 59


# Triggered by /proc/pid accesses, not allowed.
dontaudit system_server self:capability sys_ptrace;

# Trigger module auto-load.
allow system_server kernel:system module_request;

# Use netlink uevent sockets.
allow system_server self:netlink_kobject_uevent_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Use generic netlink sockets.
allow system_server self:netlink_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Set and get routes directly via netlink.
allow system_server self:netlink_route_socket nlmsg_write;

# Kill apps.
allow system_server appdomain:process { sigkill signal };

# This line seems suspect, as it should not really need to
# set scheduling parameters for a kernel domain task.
allow system_server kernel:process setsched;

# Set scheduling info for apps.
allow system_server appdomain:process { getsched setsched };
allow system_server mediaserver:process { getsched setsched };

# Read /proc/pid data for all domains. This is used by ProcessCpuTracker
# within system_server to keep track of memory and CPU usage for
# all processes on the device.

#line 90
allow system_server domain:dir { open getattr read search ioctl };
#line 90
allow system_server domain:{ file lnk_file } { getattr open read ioctl lock };
#line 90


# Write to /proc/pid/oom_adj_score for apps.
allow system_server appdomain:file write;

# Read/Write to /proc/net/xt_qtaguid/ctrl and and /dev/xt_qtaguid.
allow system_server qtaguid_proc:file { { getattr open read ioctl lock } { open append write } };
allow system_server qtaguid_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Write to /proc/sysrq-trigger.
allow system_server proc_sysrq:file { { getattr open read ioctl lock } { open append write } };

# Read /sys/kernel/debug/wakeup_sources.
allow system_server debugfs:file { getattr open read ioctl lock };

# WifiWatchdog uses a packet_socket
allow system_server self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# 3rd party VPN clients require a tun_socket to be created
allow system_server self:tun_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Notify init of death.
allow system_server init:process sigchld;

# Talk to init and various daemons via sockets.

#line 115
allow system_server property_socket:sock_file write;
#line 115
allow system_server init:unix_stream_socket connectto;
#line 115


#line 116
allow system_server installd_socket:sock_file write;
#line 116
allow system_server installd:unix_stream_socket connectto;
#line 116


#line 117
allow system_server lmkd_socket:sock_file write;
#line 117
allow system_server lmkd:unix_stream_socket connectto;
#line 117


#line 118
allow system_server mtpd_socket:sock_file write;
#line 118
allow system_server mtp:unix_stream_socket connectto;
#line 118


#line 119
allow system_server netd_socket:sock_file write;
#line 119
allow system_server netd:unix_stream_socket connectto;
#line 119


#line 120
allow system_server vold_socket:sock_file write;
#line 120
allow system_server vold:unix_stream_socket connectto;
#line 120


#line 121
allow system_server zygote_socket:sock_file write;
#line 121
allow system_server zygote:unix_stream_socket connectto;
#line 121


#line 122
allow system_server gps_socket:sock_file write;
#line 122
allow system_server gpsd:unix_stream_socket connectto;
#line 122


#line 123
allow system_server racoon_socket:sock_file write;
#line 123
allow system_server racoon:unix_stream_socket connectto;
#line 123


#line 124
allow system_server wpa_socket:sock_file write;
#line 124
allow system_server wpa:unix_dgram_socket sendto;
#line 124


# Communicate over a socket created by surfaceflinger.
allow system_server surfaceflinger:unix_stream_socket { read write setopt };

# Perform Binder IPC.

#line 130
# Call the servicemanager and transfer references to it.
#line 130
allow system_server servicemanager:binder { call transfer };
#line 130
# servicemanager performs getpidcon on clients.
#line 130
allow servicemanager system_server:dir search;
#line 130
allow servicemanager system_server:file { read open };
#line 130
allow servicemanager system_server:process getattr;
#line 130
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 130
# all domains in domain.te.
#line 130


#line 131
# Call the server domain and optionally transfer references to it.
#line 131
allow system_server binderservicedomain:binder { call transfer };
#line 131
# Allow the serverdomain to transfer references to the client on the reply.
#line 131
allow binderservicedomain system_server:binder transfer;
#line 131
# Receive and use open files from the server.
#line 131
allow system_server binderservicedomain:fd use;
#line 131


#line 132
# Call the server domain and optionally transfer references to it.
#line 132
allow system_server appdomain:binder { call transfer };
#line 132
# Allow the serverdomain to transfer references to the client on the reply.
#line 132
allow appdomain system_server:binder transfer;
#line 132
# Receive and use open files from the server.
#line 132
allow system_server appdomain:fd use;
#line 132


#line 133
# Call the server domain and optionally transfer references to it.
#line 133
allow system_server bootanim:binder { call transfer };
#line 133
# Allow the serverdomain to transfer references to the client on the reply.
#line 133
allow bootanim system_server:binder transfer;
#line 133
# Receive and use open files from the server.
#line 133
allow system_server bootanim:fd use;
#line 133


#line 134
# Call the server domain and optionally transfer references to it.
#line 134
allow system_server dumpstate:binder { call transfer };
#line 134
# Allow the serverdomain to transfer references to the client on the reply.
#line 134
allow dumpstate system_server:binder transfer;
#line 134
# Receive and use open files from the server.
#line 134
allow system_server dumpstate:fd use;
#line 134


#line 135
typeattribute system_server binderservicedomain;
#line 135


# Read /proc/pid files for dumping stack traces of native processes.

#line 138
allow system_server mediaserver:dir { open getattr read search ioctl };
#line 138
allow system_server mediaserver:{ file lnk_file } { getattr open read ioctl lock };
#line 138


#line 139
allow system_server sdcardd:dir { open getattr read search ioctl };
#line 139
allow system_server sdcardd:{ file lnk_file } { getattr open read ioctl lock };
#line 139


#line 140
allow system_server surfaceflinger:dir { open getattr read search ioctl };
#line 140
allow system_server surfaceflinger:{ file lnk_file } { getattr open read ioctl lock };
#line 140


#line 141
allow system_server inputflinger:dir { open getattr read search ioctl };
#line 141
allow system_server inputflinger:{ file lnk_file } { getattr open read ioctl lock };
#line 141


# Use sockets received over binder from various services.
allow system_server mediaserver:tcp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow system_server mediaserver:udp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };

# Check SELinux permissions.

#line 148
allow system_server selinuxfs:file { { getattr open read ioctl lock } { open append write } };
#line 148
allow system_server kernel:security compute_av;
#line 148
allow system_server self:netlink_selinux_socket *;
#line 148


# XXX Label sysfs files with a specific type?
allow system_server sysfs:file { { getattr open read ioctl lock } { open append write } };
allow system_server sysfs_nfc_power_writable:file { { getattr open read ioctl lock } { open append write } };
allow system_server sysfs_devices_system_cpu:file { open append write };

# Access devices.
allow system_server device:dir { open getattr read search ioctl };
allow system_server mdns_socket:sock_file { { getattr open read ioctl lock } { open append write } };
allow system_server alarm_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server gpu_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server iio_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server input_device:dir { open getattr read search ioctl };
allow system_server input_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server radio_device:chr_file { getattr open read ioctl lock };
allow system_server tty_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server usbaccessory_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server video_device:dir { open getattr read search ioctl };
allow system_server video_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server adbd_socket:sock_file { { getattr open read ioctl lock } { open append write } };
allow system_server audio_device:dir { open getattr read search ioctl };
allow system_server audio_device:chr_file { getattr open read ioctl lock };

# tun device used for 3rd party vpn apps
allow system_server tun_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Manage system data files.
allow system_server system_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server system_data_file:{ file lnk_file sock_file fifo_file } { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow system_server keychain_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server keychain_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/app.
allow system_server apk_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server apk_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow system_server apk_tmp_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server apk_tmp_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/app-private.
allow system_server apk_private_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server apk_private_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow system_server apk_private_tmp_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server apk_private_tmp_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage files within asec containers.
allow system_server asec_apk_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server asec_apk_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow system_server asec_public_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/anr.
allow system_server anr_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server anr_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/backup.
allow system_server backup_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server backup_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Read from /data/dalvik-cache/profiles
allow system_server dalvikcache_profiles_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow system_server dalvikcache_profiles_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/misc/adb.
allow system_server adb_keys_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server adb_keys_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/misc/sms.
# TODO:  Split into a separate type?
allow system_server radio_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server radio_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/misc/systemkeys.
allow system_server systemkeys_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server systemkeys_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Access /data/tombstones.
allow system_server tombstone_data_file:dir { open getattr read search ioctl };
allow system_server tombstone_data_file:file { getattr open read ioctl lock };

# Manage /data/misc/vpn.
allow system_server vpn_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server vpn_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/misc/wifi.
allow system_server wifi_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server wifi_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Manage /data/misc/zoneinfo.
allow system_server zoneinfo_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server zoneinfo_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Walk /data/data subdirectories.
# Types extracted from seapp_contexts type= fields.
allow system_server { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:dir { getattr read search };
# Also permit for unlabeled /data/data subdirectories and
# for unlabeled asec containers on upgrades from 4.2.
allow system_server unlabeled:dir { open getattr read search ioctl };
# Read pkg.apk file before it has been relabeled by vold.
allow system_server unlabeled:file { getattr open read ioctl lock };

# Populate com.android.providers.settings/databases/settings.db.
allow system_server system_app_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server system_app_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Receive and use open app data files passed over binder IPC.
# Types extracted from seapp_contexts type= fields.
allow system_server { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:file { getattr read write };

# Receive and use open /data/media files passed over binder IPC.
allow system_server media_rw_data_file:file { getattr read write };

# Read /file_contexts and /data/security/file_contexts

#line 260
allow system_server security_file:dir { open getattr read search ioctl };
#line 260
allow system_server security_file:file { getattr open read ioctl lock };
#line 260


# Relabel apk files.
allow system_server { apk_tmp_file apk_private_tmp_file }:{ dir file } { relabelfrom relabelto };
allow system_server { apk_data_file apk_private_data_file }:{ dir file } { relabelfrom relabelto };

# Relabel wallpaper.
allow system_server system_data_file:file relabelfrom;
allow system_server wallpaper_file:file relabelto;
allow system_server wallpaper_file:file { { { getattr open read ioctl lock } { open append write } } unlink };

# Relabel /data/anr.
allow system_server system_data_file:dir relabelfrom;
allow system_server anr_data_file:dir relabelto;

# Property Service write
allow system_server system_prop:property_service set;
allow system_server dhcp_prop:property_service set;
allow system_server net_radio_prop:property_service set;
allow system_server system_radio_prop:property_service set;
allow system_server debug_prop:property_service set;
allow system_server powerctl_prop:property_service set;
allow system_server fingerprint_prop:property_service set;

# ctl interface
allow system_server ctl_default_prop:property_service set;
allow system_server ctl_dhcp_pan_prop:property_service set;
allow system_server ctl_bugreport_prop:property_service set;
allow system_server ctl_bootanim_prop:property_service set;

# Use open file provided by bootanim.
allow system_server bootanim:fd use;

# Create a socket for receiving info from wpa.
type_transition system_server wifi_data_file:sock_file system_wpa_socket;
type_transition system_server wpa_socket:sock_file system_wpa_socket;
allow system_server wpa_socket:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow system_server system_wpa_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Remove sockets created by wpa_supplicant
allow system_server wpa_socket:sock_file unlink;

# Create a socket for connections from debuggerd.
type_transition system_server system_data_file:sock_file system_ndebug_socket "ndebugsocket";
allow system_server system_ndebug_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Specify any arguments to zygote.
allow system_server self:zygote { specifyids specifyrlimits specifyseinfo };

# Manage cache files.
allow system_server cache_file:dir { relabelfrom { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } } };
allow system_server cache_file:file { relabelfrom { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } } };

# Run system programs, e.g. dexopt.
allow system_server system_file:file { getattr execute execute_no_trans };

# LocationManager(e.g, GPS) needs to read and write
# to uart driver and ctrl proc entry
allow system_server gps_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server gps_control:file { { getattr open read ioctl lock } { open append write } };

# Allow system_server to use app-created sockets and pipes.
allow system_server appdomain:{ tcp_socket udp_socket } { getattr getopt setopt read write shutdown };
allow system_server appdomain:fifo_file { getattr read write };

# Allow abstract socket connection
allow system_server rild:unix_stream_socket connectto;

# BackupManagerService lets PMS create a data backup file
allow system_server cache_backup_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
# Relabel /data/backup
allow system_server backup_data_file:dir { relabelto relabelfrom };
# Relabel /cache/.*\.{data|restore}
allow system_server cache_backup_file:file { relabelto relabelfrom };
# LocalTransport creates and relabels /cache/backup
allow system_server cache_backup_file:dir { relabelto relabelfrom { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } } };

# Allow system to talk to usb device
allow system_server usb_device:chr_file { { getattr open read ioctl lock } { open append write } };
allow system_server usb_device:dir { open getattr read search ioctl };

# Allow system to talk to sensors
allow system_server sensors_device:chr_file { { getattr open read ioctl lock } { open append write } };

# Read from HW RNG (needed by EntropyMixer).
allow system_server hw_random_device:chr_file { getattr open read ioctl lock };

# Read and delete files under /dev/fscklogs.

#line 348
allow system_server fscklogs:dir { open getattr read search ioctl };
#line 348
allow system_server fscklogs:{ file lnk_file } { getattr open read ioctl lock };
#line 348

allow system_server fscklogs:dir { write remove_name };
allow system_server fscklogs:file unlink;

# For SELinuxPolicyInstallReceiver

#line 353

#line 353
allow system_server security_file:dir { open getattr read search ioctl };
#line 353
allow system_server security_file:file { getattr open read ioctl lock };
#line 353

#line 353

#line 353
allow system_server property_socket:sock_file write;
#line 353
allow system_server init:unix_stream_socket connectto;
#line 353

#line 353
allow system_server security_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
#line 353
allow system_server security_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
#line 353
allow system_server security_file:lnk_file { create rename unlink };
#line 353
allow system_server security_prop:property_service set;
#line 353


# logd access, system_server inherit logd write socket
# (urge is to deprecate this long term)
allow system_server zygote:unix_dgram_socket write;

# Read from log daemon.

#line 360

#line 360
allow system_server logdr_socket:sock_file write;
#line 360
allow system_server logd:unix_stream_socket connectto;
#line 360

#line 360


# Be consistent with DAC permissions. Allow system_server to write to
# /sys/module/lowmemorykiller/parameters/adj
# /sys/module/lowmemorykiller/parameters/minfree
allow system_server sysfs_lowmemorykiller:file { getattr { open append write } };

# Read /sys/fs/pstore/console-ramoops
# Don't worry about overly broad permissions for now, as there's
# only one file in /sys/fs/pstore
allow system_server pstorefs:dir { open getattr read search ioctl };
allow system_server pstorefs:file { getattr open read ioctl lock };

allow system_server system_server_service:service_manager add;

allow system_server keystore:keystore_key {
	test
	get
	insert
	delete
	exist
	saw
	reset
	password
	lock
	unlock
	zero
	sign
	verify
	grant
	duplicate
	clear_uid
	reset_uid
	sync_uid
	password_uid
};

# Allow system server to search and write to the persistent factory reset
# protection partition. This block device does not get wiped in a factory reset.
allow system_server block_device:dir search;
allow system_server frp_block_device:blk_file { { getattr open read ioctl lock } { open append write } };

# Clean up old cgroups
allow system_server cgroup:dir { remove_name rmdir };

# /oem access

#line 406
allow system_server oemfs:dir { open getattr read search ioctl };
#line 406
allow system_server oemfs:{ file lnk_file } { getattr open read ioctl lock };
#line 406


###
### Neverallow rules
###
### system_server should NEVER do any of this

# Do not allow accessing SDcard files as unsafe ejection could
# cause the kernel to kill the system_server.
neverallow system_server sdcard_type:file { { getattr open read ioctl lock } { open append write } };
#line 1 "vendor/cm/sepolicy/system_server.te"
allow system_server recovery_cache_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow system_server recovery_cache_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Persistent properties
allow system_server persist_property_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow system_server persist_property_file:file { { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } } unlink };
#line 1 "vendor/cm/sepolicy/vold.te"

#line 1
# Old domain may exec the file and transition to the new domain.
#line 1
allow init rootfs:file { getattr open read execute };
#line 1
allow init vold:process transition;
#line 1
# New domain is entered by executing the file.
#line 1
allow vold rootfs:file { entrypoint open read execute getattr };
#line 1
# New domain can send SIGCHLD to its caller.
#line 1
allow vold init:process sigchld;
#line 1
# Enable AT_SECURE, i.e. libc secure mode.
#line 1
dontaudit init vold:process noatsecure;
#line 1
# XXX dontaudit candidate but requires further study.
#line 1
allow init vold:process { siginh rlimitinh };
#line 1


# Allow vold to manage ASEC
allow vold sdcard_external:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow vold vold_tmpfs:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Allow vold to access fuse for fuse-based fs
allow vold fuse_device:chr_file { { getattr open read ioctl lock } { open append write } };

# NTFS-3g wants to drop permission
allow vold self:capability { setgid setuid };

# Vold can also run as minivold in the rootfs
#line 16

#line 1 "vendor/cm/sepolicy/property.te"
type adbtcp_prop, property_type;
type recovery_prop, property_type;
type userinit_prop, property_type;
#line 1 "vendor/cm/sepolicy/userinit.te"
type userinit_exec, exec_type, file_type;
type userinit_data_exec, file_type;

allow userinit_exec userinit_prop:property_service set;
#line 1 "vendor/cm/sepolicy/mediaserver.te"
# Themed resources (i.e. composed icons)
allow mediaserver theme_data_file:dir { open getattr read search ioctl };
allow mediaserver theme_data_file:file { getattr open read ioctl lock };
#line 1 "vendor/cm/sepolicy/auditd.te"
allow logd auditd_log:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow logd auditd_log:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

#line 1 "vendor/cm/sepolicy/healthd.te"
allow healthd self:capability { dac_override dac_read_search };
#line 1 "vendor/cm/sepolicy/system_app.te"
# For the updaters
allow system_app recovery_cache_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_app recovery_cache_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow system_app media_rw_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_app media_rw_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# Boot animation
allow system_app ctl_bootanim_prop:property_service set;
#line 1 "vendor/cm/sepolicy/drmserver.te"
allow drmserver theme_data_file:file { getattr open read ioctl lock };
#line 35 "vendor/cm/sepolicy/bootchart.te"

#line 1 "vendor/cm/sepolicy/file.te"
# Support asec containers getting mounted
allow file_type rootfs:filesystem associate;

type auditd_log, file_type, data_file_type;

# Bootchart
type bootchart_log, file_type, data_file_type;

# Themes
type theme_data_file, file_type, data_file_type;

# Performance settings
type sysfs_devices_system_iosched, file_type, sysfs_type;

# Recovery's "cache"
type recovery_cache_file, file_type, mlstrustedobject;

# Persistent property storage
type persist_property_file, file_type;

# Knobs for LiveDisplay
type livedisplay_sysfs, sysfs_type, file_type;
#line 44 "vendor/cm/sepolicy/recovery.te"

#line 1 "vendor/cm/sepolicy/system.te"
allow system_server wallpaper_file:file relabelto;
allow system_server dalvikcache_data_file:file write;

# allow adb related properties to be set
allow system_server adbtcp_prop:property_service set;

allow system_server dhcp_data_file:dir { open getattr read search ioctl };
allow system_server dhcp_data_file:file { getattr open read ioctl lock };

# Themes
allow system_server theme_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server theme_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow system_server resourcecache_data_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow system_server resourcecache_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };

# System server dynamically loads some dexfiles
allow system_server dex2oat_exec:file { { getattr open read ioctl lock } { getattr execute execute_no_trans } };
#line 1 "vendor/cm/sepolicy/uncrypt.te"

#line 1
allow uncrypt media_rw_data_file:dir { open getattr read search ioctl };
#line 1
allow uncrypt media_rw_data_file:{ file lnk_file } { getattr open read ioctl lock };
#line 1

allow uncrypt recovery_cache_file:dir { create reparent rmdir setattr { { open getattr read search ioctl } { open search write add_name remove_name } } { getattr link unlink rename } };
allow uncrypt recovery_cache_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
#line 1 "vendor/cm/sepolicy/hostapd.te"
allow hostapd netd:unix_dgram_socket sendto;
#line 1 "vendor/cm/sepolicy/zygote.te"
allow zygote theme_data_file:file { getattr open read ioctl lock };
allow zygote theme_data_file:dir { open getattr read search ioctl };

# ps command may do this
allow untrusted_app zygote:process getsched;
#line 1 "vendor/cm/sepolicy/livedisplay.te"
# Various knobs used by LiveDisplay
allow system_server livedisplay_sysfs:file { { getattr open read ioctl lock } { open append write } };
#line 1 "vendor/cm/sepolicy/su.te"
type superuser_device, file_type;

## Perms for the daemon

type sudaemon, domain;


#line 7
  
#line 7
# Old domain may exec the file and transition to the new domain.
#line 7
allow init su_exec:file { getattr open read execute };
#line 7
allow init sudaemon:process transition;
#line 7
# New domain is entered by executing the file.
#line 7
allow sudaemon su_exec:file { entrypoint open read execute getattr };
#line 7
# New domain can send SIGCHLD to its caller.
#line 7
allow sudaemon init:process sigchld;
#line 7
# Enable AT_SECURE, i.e. libc secure mode.
#line 7
dontaudit init sudaemon:process noatsecure;
#line 7
# XXX dontaudit candidate but requires further study.
#line 7
allow init sudaemon:process { siginh rlimitinh };
#line 7

#line 7

#line 7
  type_transition sudaemon socket_device:sock_file superuser_device;
#line 7
  # The userspace app uses /dev sockets to control per-app access
#line 7
  allow sudaemon superuser_device:dir { create { { open getattr read search ioctl } { open search write add_name remove_name } } setattr unlink };
#line 7
  allow sudaemon superuser_device:sock_file { create setattr unlink write };
#line 7

#line 7
  # sudaemon is also permissive to permit setenforce.
#line 7
  permissive sudaemon;
#line 7

#line 7
  # Add sudaemon to various domains
#line 7
  
#line 7
typeattribute sudaemon netdomain;
#line 7

#line 7
  
#line 7
typeattribute sudaemon appdomain;
#line 7
# Label ashmem objects with our own unique type.
#line 7

#line 7
type sudaemon_tmpfs, file_type;
#line 7
type_transition sudaemon tmpfs:file sudaemon_tmpfs;
#line 7
allow sudaemon sudaemon_tmpfs:file { read write };
#line 7

#line 7
# Map with PROT_EXEC.
#line 7
allow sudaemon sudaemon_tmpfs:file execute;
#line 7

#line 7

#line 7
  dontaudit sudaemon self:{ capability capability2 } *;
#line 7
  dontaudit sudaemon kernel:security *;
#line 7
  dontaudit sudaemon kernel:system *;
#line 7
  dontaudit sudaemon self:memprotect *;
#line 7
  dontaudit sudaemon domain:process *;
#line 7
  dontaudit sudaemon domain:fd *;
#line 7
  dontaudit sudaemon domain:dir *;
#line 7
  dontaudit sudaemon domain:lnk_file *;
#line 7
  dontaudit sudaemon domain:{ fifo_file file } *;
#line 7
  dontaudit sudaemon domain:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket } *;
#line 7
  dontaudit sudaemon domain:{ sem msgq shm ipc } *;
#line 7
  dontaudit sudaemon domain:key *;
#line 7
  dontaudit sudaemon fs_type:filesystem *;
#line 7
  dontaudit sudaemon {fs_type dev_type file_type}:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } *;
#line 7
  dontaudit sudaemon node_type:node *;
#line 7
  dontaudit sudaemon node_type:{ tcp_socket udp_socket rawip_socket } *;
#line 7
  dontaudit sudaemon netif_type:netif *;
#line 7
  dontaudit sudaemon port_type:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_firewall_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_ip6fw_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket } *;
#line 7
  dontaudit sudaemon port_type:{ tcp_socket dccp_socket } *;
#line 7
  dontaudit sudaemon domain:peer *;
#line 7
  dontaudit sudaemon domain:binder *;
#line 7
  dontaudit sudaemon property_type:property_service *;
#line 44


## Perms for the app


#line 48
  # Translate user apps to the shell domain when using su
#line 48
  #
#line 48
  # PR_SET_NO_NEW_PRIVS blocks this :(
#line 48
  # we need to find a way to narrow this down to the actual exec.
#line 48
  # typealias shell alias suclient;
#line 48
  # domain_auto_trans(untrusted_app, su_exec, suclient)
#line 48

#line 48
  allow untrusted_app su_exec:file { execute_no_trans getattr open read execute };
#line 48
  allow untrusted_app sudaemon:unix_stream_socket { connectto read write setopt ioctl };
#line 48
  allow untrusted_app superuser_device:dir { { open getattr read search ioctl } };
#line 48
  allow untrusted_app superuser_device:sock_file { write };
#line 48

#line 48

#line 48
  # For Settings control of access
#line 48
  allow system_app superuser_device:sock_file { read write create setattr unlink getattr };
#line 48
  allow system_app sudaemon:unix_stream_socket { connectto read write setopt ioctl };
#line 48
  allow system_app superuser_device:dir { create { { open getattr read search ioctl } { open search write add_name remove_name } } setattr unlink };
#line 66

#line 1 "vendor/cm/sepolicy/sysinit.te"
type sysinit, domain;
type sysinit_exec, exec_type, file_type;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init sysinit_exec:file { getattr open read execute };
#line 4
allow init sysinit:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow sysinit sysinit_exec:file { entrypoint open read execute getattr };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4
allow sysinit init:process sigchld;
#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init sysinit:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init sysinit:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init sysinit_exec:process sysinit;
#line 4

#line 4

#line 4
type sysinit_tmpfs, file_type;
#line 4
type_transition sysinit tmpfs:file sysinit_tmpfs;
#line 4
allow sysinit sysinit_tmpfs:file { read write };
#line 4

#line 4


#============= sysinit ==============
allow sysinit devpts:chr_file { { { getattr open read ioctl lock } { open append write } } };
allow sysinit shell_exec:file { { { getattr open read ioctl lock } { getattr execute execute_no_trans } } };
allow sysinit system_file:file { { { getattr open read ioctl lock } { getattr execute execute_no_trans } } };
allow sysinit self:process setcurrent;


#line 12
    allow sysinit userinit_data_exec:file { { getattr open read ioctl lock } relabelto };
#line 12
    allow sysinit property_socket:sock_file write;
#line 12
    allow sysinit init:unix_stream_socket connectto;
#line 12
    allow sysinit userinit_prop:property_service set;
#line 12
    allow sysinit sysfs:file { { getattr open read ioctl lock } { open append write } };
#line 12
    allow sysinit sysfs_devices_system_cpu:file write;
#line 12
    allow sysinit self:capability dac_override;
#line 12
    allow sysinit userinit_exec:file { { { getattr open read ioctl lock } { getattr execute execute_no_trans } } };
#line 21

#line 1 "vendor/cm/sepolicy/bootanim.te"
# Themed resources (bootanimation)
allow bootanim theme_data_file:dir search;
allow bootanim theme_data_file:file { getattr open read ioctl lock };
#line 1 "vendor/cm/sepolicy/app.te"
# Themed resources (i.e. composed icons)
allow appdomain theme_data_file:dir { open getattr read search ioctl };
allow appdomain theme_data_file:file { getattr open read ioctl lock };
#line 1 "vendor/cm/sepolicy/netd.te"
allow netd self:capability { setuid sys_module setgid };
allow netd self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd radio_data_file:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow netd radio_data_file:file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow netd wpa_socket:dir { { open getattr read search ioctl } { open search write add_name remove_name } };
allow netd wpa_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow netd system_wpa_socket:sock_file { create setattr { { getattr open read ioctl lock } { open append write } } { getattr link unlink rename } };
allow netd hostapd:unix_dgram_socket sendto;
#line 1 "vendor/cm/sepolicy/ueventd.te"
# ueventd needs to relabel files that pop in and out of sysfs
allow ueventd sysfs:file relabelfrom;

# ueventd will set permissions on cpufreq nodes
allow ueventd sysfs_devices_system_cpu:file setattr;

# ueventd loads wifi firmware on a ton of devices
allow ueventd wifi_data_file:dir { open getattr read search ioctl };
allow ueventd wifi_data_file:file { getattr open read ioctl lock };

# ueventd loads audio firmware on many devices
allow ueventd audio_data_file:dir { open getattr read search ioctl };
allow ueventd audio_data_file:file { getattr open read ioctl lock };
#line 1 "vendor/cm/sepolicy/shell.te"
allow shell adbtcp_prop:property_service set;
#line 1 "vendor/cm/sepolicy/installd.te"
# Allow querying of asec size on SD card
allow installd sdcard_external:dir { search };
allow installd sdcard_external:file { getattr };
#line 1 "vendor/cm/sepolicy/adbd.te"
allow adbd adbtcp_prop:property_service set;
#line 4 "bootable/recovery-twrp/sepolicy/twrp.te"

#line 1 "external/sepolicy/roles"
role r;
role r types domain;
#line 1 "external/sepolicy/users"
user u roles { r } level s0 range s0 - s0:c0.c1023;
#line 1 "external/sepolicy/initial_sid_contexts"
sid kernel u:r:kernel:s0
sid security u:object_r:kernel:s0
sid unlabeled u:object_r:unlabeled:s0
sid fs u:object_r:labeledfs:s0
sid file u:object_r:unlabeled:s0
sid file_labels u:object_r:unlabeled:s0
sid init u:object_r:unlabeled:s0
sid any_socket u:object_r:unlabeled:s0
sid port u:object_r:port:s0
sid netif u:object_r:netif:s0
sid netmsg u:object_r:unlabeled:s0
sid node u:object_r:node:s0
sid igmp_packet u:object_r:unlabeled:s0
sid icmp_socket u:object_r:unlabeled:s0
sid tcp_socket u:object_r:unlabeled:s0
sid sysctl_modprobe u:object_r:unlabeled:s0
sid sysctl u:object_r:proc:s0
sid sysctl_fs u:object_r:unlabeled:s0
sid sysctl_kernel u:object_r:unlabeled:s0
sid sysctl_net u:object_r:unlabeled:s0
sid sysctl_net_unix u:object_r:unlabeled:s0
sid sysctl_vm u:object_r:unlabeled:s0
sid sysctl_dev u:object_r:unlabeled:s0
sid kmod u:object_r:unlabeled:s0
sid policy u:object_r:unlabeled:s0
sid scmp_packet u:object_r:unlabeled:s0
sid devnull u:object_r:null_device:s0
#line 1 "external/sepolicy/fs_use"
# Label inodes via getxattr.
fs_use_xattr yaffs2 u:object_r:labeledfs:s0;
fs_use_xattr jffs2 u:object_r:labeledfs:s0;
fs_use_xattr ext2 u:object_r:labeledfs:s0;
fs_use_xattr ext3 u:object_r:labeledfs:s0;
fs_use_xattr ext4 u:object_r:labeledfs:s0;
fs_use_xattr xfs u:object_r:labeledfs:s0;
fs_use_xattr btrfs u:object_r:labeledfs:s0;
fs_use_xattr f2fs u:object_r:labeledfs:s0;

# Label inodes from task label.
fs_use_task pipefs u:object_r:pipefs:s0;
fs_use_task sockfs u:object_r:sockfs:s0;

# Label inodes from combination of task label and fs label.
# Define type_transition rules if you want per-domain types.
fs_use_trans devpts u:object_r:devpts:s0;
fs_use_trans tmpfs u:object_r:tmpfs:s0;
fs_use_trans devtmpfs u:object_r:device:s0;
fs_use_trans shm u:object_r:shm:s0;
fs_use_trans mqueue u:object_r:mqueue:s0;

#line 1 "external/sepolicy/genfs_contexts"
# Label inodes with the fs label.
genfscon rootfs / u:object_r:rootfs:s0
# proc labeling can be further refined (longest matching prefix).
genfscon proc / u:object_r:proc:s0
genfscon proc /net u:object_r:proc_net:s0
genfscon proc /net/xt_qtaguid/ctrl u:object_r:qtaguid_proc:s0
genfscon proc /cpuinfo u:object_r:proc_cpuinfo:s0
genfscon proc /sysrq-trigger u:object_r:proc_sysrq:s0
genfscon proc /sys/fs/protected_hardlinks u:object_r:proc_security:s0
genfscon proc /sys/fs/protected_symlinks u:object_r:proc_security:s0
genfscon proc /sys/fs/suid_dumpable u:object_r:proc_security:s0
genfscon proc /sys/kernel/core_pattern u:object_r:usermodehelper:s0
genfscon proc /sys/kernel/dmesg_restrict u:object_r:proc_security:s0
genfscon proc /sys/kernel/hotplug u:object_r:usermodehelper:s0
genfscon proc /sys/kernel/kptr_restrict u:object_r:proc_security:s0
genfscon proc /sys/kernel/modprobe u:object_r:usermodehelper:s0
genfscon proc /sys/kernel/modules_disabled u:object_r:proc_security:s0
genfscon proc /sys/kernel/poweroff_cmd u:object_r:usermodehelper:s0
genfscon proc /sys/kernel/randomize_va_space u:object_r:proc_security:s0
genfscon proc /sys/kernel/usermodehelper u:object_r:usermodehelper:s0
genfscon proc /sys/net u:object_r:proc_net:s0
genfscon proc /sys/vm/mmap_min_addr u:object_r:proc_security:s0
genfscon proc /sys/vm/dirty_ratio  u:object_r:proc_dirty_ratio:s0
# selinuxfs booleans can be individually labeled.
genfscon selinuxfs / u:object_r:selinuxfs:s0
genfscon cgroup / u:object_r:cgroup:s0
# sysfs labels can be set by userspace.
genfscon sysfs / u:object_r:sysfs:s0
genfscon inotifyfs / u:object_r:inotify:s0
genfscon vfat / u:object_r:vfat:s0
genfscon debugfs / u:object_r:debugfs:s0
genfscon fuse / u:object_r:fuse:s0
genfscon pstore / u:object_r:pstorefs:s0
genfscon functionfs / u:object_r:functionfs:s0
genfscon usbfs / u:object_r:usbfs:s0
#line 1 "vendor/cm/sepolicy/genfs_contexts"
genfscon fuseblk / u:object_r:sdcard_external:s0
#line 1 "external/sepolicy/port_contexts"
# portcon statements go here, e.g.
# portcon tcp 80 u:object_r:http_port:s0

